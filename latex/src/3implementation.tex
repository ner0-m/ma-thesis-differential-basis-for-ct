\chapter{elsa}\label{chap:elsa}

I want to dedicate this chapter to the C++ framework \textit{elsa}~\cite{lasser_elsa_2019} developed
at the \gls{CIIP} research group. As the practical part of my thesis is implemented for elsa, I feel
that a short introduction is more than appropriate.

elsa is a modern, flexible and open-source framework for tomographic reconstruction. I consider elsa
to follow three important principles. First, and possibly most importantly for the user side, it
should be close to mathematical notation and mathematical concepts. Second, it should be useful for
the research done at the \gls{CIIP} research group. And finally, it should be as easy as possible
for others to reproduce results from the research. These different aspects have to be wagered
against each other, as they might stand in conflict.

elsa is able to handle general optimization problems similar to the form given in
\autoref{eq:optimization_problem}. However, it can handle an even more general problem state of the
form:
\begin{equation}\label{eq:complex_optimization_problem}
	\argmin_{\mvec{c}} \quad T(A, \mvec{c}, \mvec{m}) + \sum_{k=1}^K \lambda_k R_k(\mvec{c})
\end{equation}
where, \(T\) is the data fidelity term depending on the forward model \(A\), the solution
\(\mvec{c}\), the measurements \(\mvec{m}\), \(K\) penalty or regularization terms depending on
\(\mvec{c}\) and \(\lambda_k\) is a regularization parameter for the \(k\)th penalty term (compare
\autoref{def:regularized_problem} with a single penalty term).

Building the framework around this general problem statement enables the implementation of multiple
imaging modalities in one framework. Currently, only X-ray attenuation CT is implemented. However,
from a theoretical standpoint other modalities such as phase-contrast CT and (anisotropic) dark-field
CT can be incorporated. Plus many aspects of the framework are independent of the specific
application, and reusable. I.e.\ one needs no different implementation of algorithms solving the
above given equations such as \gls{ART}, or \gls{ISTA}\@.

This is a key difference to other frameworks such as the ASTRA Toolbox~\cite{van_aarle_fast_2016},
TIGRE~\cite{biguri_tigre_2016} or FreeCT~\cite{hoffman_technical_2016}. All of these frameworks are
known and widely used frameworks in the field of tomographic reconstruction. Also, there are other
frameworks supporting multiple imaging modalities. However, their goal is not such a general
approach. This generality is key for the research at the \gls{CIIP} research group.

From a software engineering standpoint, a lot of effort is put into reproducibility, maintenance and
correctness, by following numerous best practices. This includes having an extensive unit testing
suite (though, we can still improve it), a merge request based workflow, which heavily relies on
continuous integration, we try to follow modern C++ guidelines, rely on modern features from newer
standards such as C++17, and try to rely on important tools such as
\textit{clang-tidy}~\cite{noauthor_clang-tidy_nodate} and
\textit{AddressSanitizer}~\cite{noauthor_addresssanitizer_2021}. Further, to ease prototyping and
improve accessibility Python bindings are provided as well.

The general architecture is build in a couple of layers. At the bottom, all data handling is done by
the \mintinline{cpp}{DataContainer} class. It is the one type to store and handle all
\(n\)-dimensional data in the framework. It handles storage for data accessible by the \gls{CPU} and
the \gls{GPU} and transfers between those two. Further, it leverages expression templates to reduce
the general memory footprint of applications. Above that, the mathematical concepts are implemented.
These include concepts for residuals, functionals (such as \(l_1\), \(l_2\), or the Huber norm) and
linear operators (modeling both the forward models and operators such as scaling or finite
differences). Finally, it also includes an abstraction for the different algorithms solving
optimization problems.

Currently, two different approximations are implemented for the line integral forward models. Both
have a \gls{CPU} and \gls{GPU} (specifically NVidia's CUDA) version available. As the forward and
backward projection are usually the computationally most expensive. The specific implemented methods
are referred to as Siddon's and Joseph's method. See \autoref{chap:projector} for details.

I will refer the interested reader to
\href{https://gitlab.lrz.de/IP/elsa/}{https://gitlab.lrz.de/IP/elsa/}. There, one can find guides to
install and use elsa extensively, including code examples.

\chapter{Projector}\label{chap:projector}

As shown in previous chapters, calculation of the system matrix coefficients is one of the key
components of tomographic reconstruction. Thus, this has been an important part of research. The
routines or algorithms, which calculate the matrix are frequently referred to as
\textit{projectors}. For the forward projection, the contribution of each voxel to each detector
pixel is calculated. For the backward projection, the contribution of each detector pixel to each a
voxel is computed.

In the first part of this chapter, a detailed overview over existing research and implementations of
projectors is given. Next details on the projector used for this thesis is given. This is followed
by a detailed study of accuracy and performance of the new projector compared to other projection
methods in \autoref{chap:experiments}.

\section{Types of Projectors}\label{sec:projector_types}

One of the first mentions of projector routines can be found in the RECLBL library
package~\cite{huesman_reclbl_1977}. Namely, the two types of projectors introduced there are the
\textit{voxel-driven} (or \textit{pixel-driven} for the 2D case) and the \textit{ray driven}. Many
state-of-the-art projectors are still based on the ideas of these projectors.

The voxel driven approach is very simple. For the forward projection, each voxel is visited, and the
voxel center is projected onto the detector. Finally, the contribution of the voxel to the detector,
is computed using some form of interpolation. In~\cite{peters_algorithms_1981} bilinear
interpolation between the two neighboring detector pixels is used.~\cite{harauz_interpolation_1983}
improves on the approach by using bi-cubic spline interpolation. However, the approach is used
rarely due to the introduced artifacts (C.f.~\cite[Chapter~3.3]{levakhina_three-dimensional_2014}).
I.e.\ if the resolution of the detector is finer compared to the volume, detector pixels might never
be assigned a value. The same operation can be performed for the back projection, however instead of
updating the value at the detector pixel, update the voxel value.

Instead of projecting the voxel center and interpolating, one can project the complete voxel onto
the projector plane. This approach was taken in~\cite{long_3d_2010, long_3d_2010-1} and is usually
referred to as separable footprint. They use trapezoidal functions to approximate the footprint both
accurately and efficiently. Hence, the contribution of voxels to the detector pixels is based on
these trapezoidal functions. It as also been ported to \gls{GPU} as shown in~\cite{wu_gpu_2011,
	xie_effective_2015, chapdelaine_new_2018}. To the best of my knowledge, for voxel based
approaches, this is the state-of-the-art approach and outperforms other approaches.

This approach was translated to B-Splines in~\cite{momey_b-spline_2012, momey_spline_2015}. There
B-Splines are assumed to be the basis function at pixel centers, and then the B-Splines are
projected onto the projector plane. As shown in \autoref{chap:signal_representation} about B-Spline
basis functions the projection of \(n\)-dimensional B-Splines yield a \(n-1\)-dimensional B-Spline,
hence the projection is simple and accurate.~\cite{momey_b-spline_2012} already incorporated both
parallel-beam and cone-beam geometry.

Similarly,~\cite{ziegler_efficient_2006} proposed a footprint approach for blobs. And it was
improved and ported to the \gls{GPU} in~\cite{bippus_projector_2011}.~\cite{kohler_iterative_2011}
describes a blob projector for phase-contrast CT\@.

A shared problem of the voxel-based approaches, is the challenge of parallel implementations. During
the forward projection, shared access to the projector pixels might be needed. Hence, mitigation
strategies must be developed.

A conceptually different approach compared to the voxel-based or footprint approaches, is the
\textit{ray-based} approach. There, the key idea is to trace rays through the volume. Note that the
forward projection of this approach, is trivially parallelizable. Each ray can be traced
independently through the volume.

A classical ray-driven approach is presented by \citeauthor*{siddon_fast_1985}
in~\cite{siddon_fast_1985}. Hence, it is often referred to as Siddon's method. There, the exact path
length of a ray traversing through an image or volume is calculated. This is also illustrated in
\autoref{fig:visualization_siddon_traversal}. More recent work
like~\cite{jacobs_fast_1998,christiaens_fast_1999,zhao_fast_2004, gao_fast_2012} improved on the
Siddon's method, especially in efficiency and
performance.~\cite{de_greef_accelerated_2009,xiao_efficient_2012} ported Siddon's methods to the
\gls{GPU}\@.

\begin{figure}
	\centering
	% Taken from https://tex.stackexchange.com/a/398309
	\includegraphics[width=0.75\textwidth]{./figures/projectors_siddon/siddon_traversal.png}
	\caption{Visualization of Siddon's method. Siddon's method exactly computes the intersection
		length of each voxel (text inside each voxel) with a ray (cardinal red line), which
		is used as a weight for the forward and backward projections. The intersection
		length for each voxel is given by the distance between the points where the ray
		enters and exists each voxel (marked as black
		dots).}\label{fig:visualization_siddon_traversal}
\end{figure}

Another classic is presented in~\cite{joseph_improved_1982} by \citeauthor{joseph_improved_1982}. It
is often referred to as Joseph's method. It assumes a smooth image and interpolates between
neighboring voxels along the ray path. It does so by a slice-interpolation, i.e.\ the voxels
perpendicular to the main ray direction are considered.~\cite{graetz_high_2020} proposed a
branchless \gls{GPU} version of this approach.

The backward projections of ray-driven approaches typically trace the ray from a detector pixel to
the source and update all visited voxels based on the weights calculated as in the forward
direction. And in the backward projection of the Joseph's based methods, voxels close by are also
updated. Note again here, that parallelization is hindered by the possibility of shared write access
to voxels.

The Siddon's and Joseph's method are classic and common approaches for the forward and backward
projection. However, they do suffer from certain high-frequency artifacts. This is especially true
for Siddon's method. Due to the interpolation of the Joseph's method, less artifacts appear there.
Such artifacts can be seen in the experiment section of this thesis (\autoref{chap:experiments}).

An entirely different approach to both the voxel- and ray-driven methods is the
\textit{distance-driven} approach proposed by \citeauthor*{de_man_distance-driven_2002} in
~\cite{de_man_distance-driven_2002,de_man_distance-driven_2004}. There, the voxel boundaries and
detector pixel boundaries are projected onto a common axis, then the overlap is used as a weight.
This approach is still considered state-of-the-art, however, is suffers from inaccuracies for
projections, which are close to \(45^\circ\). A branchless \gls{GPU} version was proposed
in~\cite{liu_gpu-based_2017}. The distance-driven approach doesn't suffer from any high-frequency
artifacts like Siddon's or Joseph's methods do.

Projectors based on blobs have been studied for quite some time. Ray-driven approaches are based on
algorithms presented in~\cite{matej_practical_1996,popescu_ray_2004}. But rather than assuming an
infinitely thin ray, they assume a beam. Hence, they are somewhat similar to Joseph's projectors,
that they have to visit neighboring voxels, as the support of blobs is larger than that of pixels.
~\cite{levakhina_distance-driven_2010} proposed a variant of the distance-driven approach based on
blobs.

Another class of projectors computes the intersection area of multiple rays. Such methods, as
presented in~\cite{ha_study_2015,ha_efficient_2016,ha_look-up_2018}, calculate the intersection
between rays directed a detector boundary.

Typically, iterative reconstruction algorithms expect that the forward and backward projectors are
the adjoint of each other, i.e.\ they are a \textit{matched} projector
pair~\cite{zeng_unmatched_2000}. If the system matrix \(A\) is constructed using one projector, then
the backward projector should construct \(A^T\), i.e.\ the transpose of the matrix. If the abstract
view of linear bounded operators is taken, this would be the aforementioned adjoint.

Using an unmatched projector pair might be beneficial, as one projector algorithm might be slower
for the forward projection than the back projection or vice-versa. Hence, one might want to pick the
fastest for the forward projection and another for the back projection. However, iterative
reconstruction algorithms usually expect the backward projection to be the adjoint of the forward
projection. If this is not met, convergence might not be guaranteed.
\citeauthor*{zeng_unmatched_2000}~\cite{zeng_unmatched_2000} describes conditions, which unmatched
detector pairs must meet.

\section{Implementation of Differentiable Projection Operators}\label{sec:implementation}

The goal of the practical part of the thesis, is an implementation of a projector based on
differential basis functions. Specifically, the projectors implemented are based on the blob and
B-Spline basis function as presented in \autoref{chap:signal_representation}.

The forward model is implemented in elsa, and can be found in the master branch. This section covers
a general overview of the algorithm, plus some details on the implementation. Referring to the
definition of image given in \autoref{def:signal}, this method works for both \(2\) and \(3\)
dimensional images, however, to avoid repetition, I will only talk about images and refer to both.

For both the forward and backward projection, the implemented algorithm can be categorized as a
ray-driven approach. I.e.\ it traverses each ray through the image going form all the poses defined
to each detector pixel.

Given a ray, the first step is a quick intersection test of the ray and the bounding box of the
image. If the ray hits the bounding box, it needs to traverse the regular spaced grid of the image.
The specific traversal algorithm is based on~\cite{amanatides_fast_1987}, however it is simplified.
In \autoref{fig:visualization_siddon_traversal} the steps the algorithm would take can be seen. It
ensures, each voxel is visited, even if it is only for a small amount.

For the purpose of this projector, however, the basis functions considered have a support larger
than a single voxel. Hence, the previous algorithm can be simplified to traverse in a
\textit{slice-by-slice} fashion. Specifically, this means, that the algorithm only steps a fixed
width in the leading direction of the given ray. The voxels visited this way are referred to as
\textit{center voxels}, as they are the center of a given slice. Then for each center voxel, the
neighboring voxels perpendicular to the leading direction are visited for a given distance. The
distance depends on the specific choice of basis function and their parameters. This is depicted in
\autoref{fig:visualization_slice_traversal}.

\begin{figure}[h]
	\centering
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/projectors_slice/slice_traversal.png}
				\caption{}\label{fig:visu_slice_traver_a}%
			\end{subfigure}%
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/projectors_slice/slice_traversal_clean.png}
				\caption{}\label{fig:visu_slice_traver_b}%
			\end{subfigure}
		}}
	\caption{\subref{fig:visu_slice_traver_a} Visualization of the voxels visited
		for the slice traversal. The ray (cardinal red line) traverses the image. For each
		center voxel (darker blue), neighbor voxels (light blue) perpendicular to the
		leading direction (here the x-direction) are visited for a certain distance (here
		the distance is \(1\)). The center voxels are traversed by the distance to the ray
		origin, in this visualization on the left, going to the right. The dotted black
		lines indicate the perpendicular distance from the voxel center to the ray.
		\subref{fig:visu_slice_traver_b} same setting as in
		\subref{fig:visu_slice_traver_a}, however, the support of the basis function is
		depicted (black circle), only for a single slice. There the intersection between the
		ray and the circle is the Radon Transform of the ray and the contribution of the
		basis function to the projection.
	}\label{fig:visualization_slice_traversal}
\end{figure}

The next important part of the projector is the evaluation of the weight for each visited voxel.
Looking at \autoref{fig:visualization_slice_traversal}, the dotted black lines indicate the
distances from the voxel center to the ray. These distances are used to compute the Radon Transform
of the given basis function.

In the case of blob basis functions, the closed form solution given in \autoref{eq:radon_blob_basis}
is used with \(r\) being exactly the distance just mentioned. In the case of B-Splines it is just a
touch more complicated. As explained in \autoref{sec:bspline_basis}, the projected B-Spline are
again B-Splines. However, B-Splines are not perfectly spherically-symmetric. But they are close
enough to assume it (compare~\cite{momey_b-spline_2012, momey_spline_2015} for more details). Hence,
it is assumed that the B-Spline are spherically-symmetric, and therefore the evaluation (and using
their separability) simplifies to
\begin{equation}
	\radon\beta^d(r) \approx \beta^d(r) \prod^{n - 1}_{k=1} \beta^d(0)
\end{equation}
For both basis functions, a \gls{LUT} is computed first for the creation of the projector, and the
for the actual projections the values are looked up.

The same traversal and evaluation methods are used for both the forward and backward projection, and
hence no further discussion is needed here. However, one more point should be noted for the sake of
completeness. As \citeauthor*{momey_spline_2015}~\cite{momey_spline_2015} showed for B-Splines and
\citeauthor*{kohler_iterative_2011}~\cite{kohler_iterative_2011} for blobs, it is possible to use
footprints instead of a ray-driven approach for both basis functions. The only reason this was not
pursued during this thesis, is the lack of experience of the footprint based methods in elsa. This
definitely is a possible area of improvement in the projector, see \autoref{chap:future_work}.

Also note, the current version of the projector only supports X-ray attenuation CT\@. However, this
projector should be easily adapted to instead of the Radon Transform, yield the derivative of the
Radon Transform as weights. In theory, it should only be necessary to create a function to populate
the \gls{LUT}, and a very thing wrapper around it to provide the functionality needed for elsa to
use it as a projector.

As already touched on in \autoref{sec:blob_basis} and \autoref{sec:bspline_basis} both basis
functions provide a couple of important parameters. Especially, the blob basis function depends on
the exact values used for \(m\), \(\alpha\) and \(a\). Regarding B-Splines, they only have the
parameter regarding the order \(d\). For the projector based on B-Splines, only cubic B-Splines are
supported for now. The rationale is given in \autoref{sec:bspline_basis}. The projector using the
blob basis function is configurable, and the parameters can be passed to projector.

\chapter{Experiments}\label{chap:experiments}

After discussing many aspects of the tomographic reconstruction, and the presentation of the
implementation of two projectors. The projectors are thoroughly tested and investigated. This
chapter structured is as follows: Before diving into the experiments itself, a quick overview of the
different error metrics is given. This is followed by a series of experiments. These experiments
include the forward projection of the projectors, and the reconstruction with 3 different phantoms.
The phantoms vary in complexity to analyze different behaviors. Also, an experiment using synthetic
noise is conducted. The final part of the analysis covers runtime performance of the projectors.

Reproducibility is important. Therefore, all experiments can be run with the main branch of
elsa. Please check out the \href{https://gitlab.lrz.de/IP/elsa}{GitLab repository} to find
instructions on how to build and run elsa. All experiments are based on the
\textit{example\_argparse} in the \textit{example} folder of the repository.

As all the experiments are run using elsa. Hence, some necessary details which hold for all the
experiment setups are given later on. The overall geometric setup elsa follows is as described in
\citeauthor{hartley_multiple_2003}~\cite{hartley_multiple_2003}. The CT projection geometry uses a
cone beam geometry, with flat detector. Further, elsa is itself unitless. Therefore, all distances
are given in relation to pixel sizes.

\section{Error measurements}\label{sec:error_measurements}

Error measurements are a delicate topic. They can fake a false sense of security. Metrics might
indicate an improved result, however visually the result might be worse. Therefore, multiple error
metrics are taken into considerations here.

\begin{definition}[Mean Squared Error]
	One of the most famous error metrics: \textit{\gls{MSE}}. It is defined as the
	squared differences of each pixel value, weighted with the total number of pixels
	\[ MSE(\mvec{x}, \hat{\mvec{x}}) = \frac{1}{n} \sum_{i=1}^{n}(\mvec{x}_i - \hat{\mvec{x}}_i)^2\]
	where \(\mvec{x}_i\) is each voxel of the reference image, \(\hat{\mvec{x}}_i\) each voxel
	of the comparison image and \(n\) the total number of voxels in the image.
\end{definition}

Building on top of the \gls{MSE}, the \textit{\gls{RMSE}}, is the square root of the
\gls{MSE}.
\begin{definition}[Normalized Root Mean Squared Error]
	The \textit{\gls{RMSE}} is defined as
	\[ RMSE(\mvec{x}, \hat{\mvec{x}}) = \sqrt{MSE(\mvec{x}, \hat{\mvec{x}}}) \]
	where \(\mvec{x}\) is the reference image and \(\hat{\mvec{x}}\) the comparison image.
	Further, the \textit{\gls{NRMSE}} is defined as
	\[ NRMSE(\mvec{x}, \hat{\mvec{x}}) = \frac{RMSD}{\mvec{x}_{max} - \mvec{x}_{min}} \]
	with \(\mvec{x}_{min}\) and \(\mvec{x}_{max}\) are the minimum and maximum values of the
	reference image, respectively.
\end{definition}
Another frequently used metric is the \textit{\gls{PSNR}}
\begin{definition}[Peak Signal to Noise Ration]
	The \textit{\glsfirst{PSNR}} is defined as
	\[ PSNR(\mvec{x}, \hat{\mvec{x}}) = 10 \cdot \log_{10}\left( \frac{MAX(\mvec{x})}{\sqrt{MSE(\mvec{x}, \hat{\mvec{x}})}} \right) \]
	where \(MAX(\mvec{x})\) is the maximum possible range depending on the data type of the
	images.
\end{definition}

All the so far given metrics are based on the \gls{MSE}, i.e.\ they measure based on exact voxel by
voxel values. They measure absolute errors and weight them depending on the exact method. However,
they do not necessarily have much in common with the visual perception of humans. The
\textit{\gls{SSIM}}~\cite{wang_image_2004,avanaki_exact_2009} is a perception-based approach. Rather
than a pixel to pixel relation, \gls{SSIM} use the relation of pixels in close proximity to each
other. Plus some other important values important to the human perception.
\begin{definition}[Structural Similarity Index Measure]
	Given a reference image \(\mvec{x}\) and a comparison image \(\hat{\mvec{x}}\) then the
	\textit{\glsfirst{SSIM}} is
	\[ SSIM(\mvec{x}, \hat{\mvec{x}}) =
		\frac{
			\left( \mu_{\mvec{x}} \mu_{\hat{\mvec{x}}} + c_1 \right)
			\left( 2 \sigma_{\mvec{x}, \hat{\mvec{x}}} + c_2 \right)
		}{
			\left( \mu_{\mvec{x}}^2 + \mu_{\hat{\mvec{x}}}^2 + c_1 \right)
			\left( \sigma_{\mvec{x}}^2 + \sigma_{\hat{\mvec{x}}}^2 + c_2 \right)
		}
	\]
	where \(\mu_{\mvec{x}}\) and \(\mu_{\hat{\mvec{x}}}\) is the average of \(\mvec{x}\)
	and \(\hat{\mvec{x}}\) respectively, \(\sigma_{\mvec{x}}^2\) is the variance of \(\mvec{x}\),
	\(\sigma_{\hat{\mvec{x}}}^2\) is the variance of \(\hat{\mvec{x}}\), and \(\sigma_{\mvec{x},
		\hat{\mvec{x}}}\) is the covariance of \(\mvec{x}\) and \(\hat{\mvec{x}}\)
\end{definition}
The promise that the value returned by \gls{SSIM} a value in the range \([0, 1]\), and if the value
is closer to one, it is `better' for the human perception.

Throughout the experiment sections, all error metrics are calculated the same way. The error norms
are computed using the scikit python package~\cite{van_der_walt_scikit-image_2014}. The snippet of
python code in Listing \autoref{py:error_metric} illustrates this.

\begin{listing}[h]
	\begin{minted}{python}
from skimage.metrics import structural_similarity
from skimage.metrics import mean_squared_error
from skimage.metrics import normalized_root_mse
from skimage.metrics import peak_signal_noise_ratio

# Assuming both phantom and reconstruction are read in somehow
MSE = mean_squared_error(phantom, reconstruction)
NRMSE = normalized_root_mse(phantom, reconstruction)
PSNR = peak_signal_noise_ratio(phantom, reconstruction)
SSIM = structural_similarity(phantom, reconstruction,
        data_range=phantom.max() - phantom.min())
    \end{minted}
	\caption{Computation of \gls{MSE}, \gls{NRMSE}, \gls{PSNR} and \gls{SSIM} using the scikit
		python package.}\label{py:error_metric}
\end{listing}

\section{Forward Projection}\label{sec:experiments_forward_projection}

As explained in detail in the background part of thesis, the forward projection is in the case of
attenuation X-ray CT, the line integral through the object. Its quality is essential for every
reconstruction task.

For this section, the sinograms of the Shepp-Logan phantom~\cite{shepp_fourier_1974} (shown in
\autoref{fig:overview_shepp_logan_phantom}) are compared. The sinogram is computed for each
different projector method (the projector using blobs and B-Splines, Siddon's and Joseph's method).
The projection is performed in \(2\)D. The resolution of the initial phantom is \(512 \times 512\)
pixel. The sinogram is computed for a total of \(768\) projection angles arranged equally spaced in
a full circle around the object. The source is \(51200\) units away from the image center and the
detector is \(512\) units away. The one-dimensional flat detector has a resolution of \(\lfloor 512
* \sqrt{2} \rfloor = 724\) for each pose.

A similar setup was used for the three-dimensional forward projection. Apart from the difference in
dimension, it uses a phantom with size \(256 \times 256 \times 256\) voxels. The detector is flat
and a complete (i.e.\ \(360^\circ\)) circular trajectory around the object is used. The detector has
a resolution of \(362 \times 362\) pixels. In total \(384\) equally spaced projection poses are
acquired equivalent to a rotation around the \(y\)-axis, with the center of rotation being the
center of the volume. The distance from the source to the center is \(25600\) units and the distance
from the center of the volume to the principal point of the detector is \(256\) units.

The recommendations discussed in \autoref{chap:signal_representation} are followed for the
parameters of the basis functions. The projector using B-Splines uses cubic B-Splines. And the blob
parameters as discussed by~\cite{levakhina_three-dimensional_2014} are followed, i.e.\ \(m = 2\),
\(\alpha = 10.83\) and \(a = 2\).

\begin{figure}
	\centering

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[x=-3.75em, y=0em]{90}{\bfseries Forward projections\strut}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Blob Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_Blob_windowed.png}}
				\subcaption{}\label{fig:sinogram_blob}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Cubic B-Spline Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_BSpline_windowed.png}}
				\subcaption{}\label{fig:sinogram_bspline}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Siddon's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_Siddon_windowed.png}}
				\subcaption{}\label{fig:sinogram_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Joseph's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_Joseph_windowed.png}}
				\subcaption{}\label{fig:sinogram_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[x=-2.5em, y=0em]{90}{\bfseries Abs.\ Normalized Difference\strut}
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_difference_Blob_Siddon_windowed.png}
				\subcaption{}\label{fig:sino_diff_blob_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_difference_Blob_Joseph_windowed.png}
				\subcaption{}\label{fig:sino_diff_blob_joseph}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_difference_BSpline_Siddon_windowed.png}
				\subcaption{}\label{fig:sino_diff_bspline_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_difference_BSpline_Joseph_windowed.png}
				\subcaption{}\label{fig:sino_diff_bspline_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}[t]{0.275\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_difference_Blob_BSpline_windowed.png}
				\subcaption{Absolute normalized difference between Blob and cubic
					B-Spline projector}\label{fig:sino_diff_blob_bspline}
			\end{subfigure}
			\begin{subfigure}[t]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/plot_sino_differences.png}
				\subcaption{Cross-section of \(180\)° projection}\label{fig:plot_sino_differences}
			\end{subfigure}
			\begin{subfigure}[t]{0.30\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dphantom_windowed.png}
				\subcaption{Shepp-Logan phantom}\label{fig:forward_shepp_logan_phantom}
			\end{subfigure}%
		}}
	\caption{\subref{fig:sinogram_blob}--\subref{fig:sinogram_joseph} sinogram of \(512 \times
		512\) Shepp-Logan phantom for the Blob based, B-Spline based, Siddon's and Joseph's
		projector (left to right), with \(786\) different poses in a \(360\)° arc around the
		phantom using fan-beam geometry. The blob parameters used are \(m=2\),
		\(\alpha=10.83\) and \(a=2\). The B-Spline basis function used has order \(3\).%
		\subref{fig:sino_diff_blob_siddon}--\subref{fig:sino_diff_bspline_joseph} Absolute
		difference of normalized sinograms between (from left to right), the blob based to
		Siddon's and Joseph's projector, then the B-Spline based to Siddon's and Joseph's
		projector. \subref{fig:sino_diff_blob_bspline} Absolute difference of normalized
		difference between the sinogram for the Blob based and B-Spline based projector.%
		\subref{fig:plot_sino_differences} Plot of cross sections at \(180\)° (i.e.\ the
		center row) of sinograms. The intensity difference of the Blob based projector
		compared to the others is clearly visible. \subref{fig:forward_shepp_logan_phantom}
		original Shepp-Logan phantom used to create the sinograms}%
	\label{fig:sinogram_shepp_logan}
\end{figure}

Looking at \autoref{fig:sinogram_shepp_logan}, an overview of the forward projection for the
different projectors is shown. A first obvious observation: All of the forward projections are
acceptable. There exist differences (as it can be seen in the second and third row of
\autoref{fig:sinogram_shepp_logan}), but one has to look more in-depth. Staying with the overview
first and looking at the first row, one should note the extreme difference in displayed values. The
projectors based on the blob basis functions is noticeably brighter. This is reconfirmed with the
plot in \autoref{fig:plot_sino_differences}. The plot shows a cross-section slice of the sinogram at
\(180^\circ\). There it is clear, the blob based projector has a throughout higher intensity value.
This also motivates the choice of absolute normalized differences. Focusing on the overall visible
artifacts, one can see in the different images
(\autoref{fig:sino_diff_blob_siddon}--\autoref{fig:sino_diff_bspline_joseph}), artifacts most
notable appear in the comparison to the Siddon's projector. The area around angles multiples of
\(90^\circ\) exhibit clearly high-frequency artifacts. Especially, in the boundary portion of the
sinogram. The blob and B-Spline based projectors compared to the Joseph's have the most visible
difference at multiples of \(45^\circ\). Lastly looking at the difference between the blob and
B-Spline based projector in \autoref{fig:sino_diff_blob_bspline}, one can see clear differences in
at multiples of \(45^\circ\).

\begin{figure}
	\centering

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[x=-3.5em, y=0em]{90}{\bfseries Forward projections\strut}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Blob Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_cropped_Blob_windowed.png}}
				\caption{}\label{fig:sinogram_blob_center_crop}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Cubic B-Spline Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_cropped_BSpline_windowed.png}}
				\caption{}\label{fig:sinogram_bspline_center_crop}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Siddon's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_cropped_Siddon_windowed.png}}
				\caption{}\label{fig:sinogram_siddon_center_crop}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Joseph's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_cropped_Joseph_windowed.png}}
				\caption{}\label{fig:sinogram_joseph_center_crop}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[x=-2.em, y=0em]{90}{\bfseries Abs.\ Normalized Difference\strut}
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_cropped_difference_Blob_Siddon_windowed.png}
				\caption{}\label{fig:sinogram_difference_blob_siddon_crop}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_cropped_difference_Blob_Joseph_windowed.png}
				\caption{}\label{fig:sinogram_difference_blob_joseph_crop}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_cropped_difference_BSpline_Siddon_windowed.png}
				\caption{}\label{fig:sinogram_difference_bspline_siddon_crop}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_cropped_difference_BSpline_Joseph_windowed.png}
				\caption{}\label{fig:sinogram_difference_bspline_joseph_crop}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}[t]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_cropped_difference_Blob_BSpline_windowed.png}
				\caption{Sinogram with marked region of crops}\label{fig:sinogram_difference_blob_bspline_crop}
			\end{subfigure}
			\begin{subfigure}[t]{0.30\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_Blob_rectangle.png}
				\caption{Sinogram with marked region of crops}\label{fig:sinogram_crop_overview}
			\end{subfigure}%
		}}
	\caption{\subref{fig:sinogram_blob_center_crop}--\subref{fig:sinogram_joseph_center_crop}
		crop into the sinogram shown in \autoref{fig:sinogram_shepp_logan} (i.e.\ sinogram
		created from a \(512 \times 512\) Shepp-Logan phantom using \(786\) projection poses
		positioned in a full \(360^\circ\) circular trajectory). The crop shows part of the
		projections of around \(180\)° to \(225\)°. The blob parameters used are \(m=2\),
		\(\alpha=10.83\) and \(a=2\). The B-Spline basis function used has order \(3\).
		\subref{fig:sinogram_difference_blob_siddon_crop}--\subref{fig:sinogram_difference_blob_bspline_crop}
		same cropped region as the first row, but showing the absolute normalized
		differences. \subref{fig:sinogram_crop_overview} sinogram with rectangle marking the
		cropped region images in
		\subref{fig:sinogram_blob_center_crop}--\subref{fig:sinogram_difference_bspline_joseph_crop}
	}
	\label{fig:sinogram_shepp_logan_cropped}
\end{figure}

Taking a closer look in \autoref{fig:sinogram_shepp_logan_cropped}, a crop of the results from
\autoref{fig:sinogram_shepp_logan} can be seen. Specifically, a crop that contains a portion of the
projections with angles \([180^\circ, 225^\circ]\). In this close up, the typical ring like
artifacts
of ray-driven projectors can be clearly seen in the forward projection of the Siddon's projector
(\autoref{fig:sinogram_siddon_center_crop}). The other sinograms look clean even on this scale.
Looking at the second row of \autoref{fig:sinogram_shepp_logan_cropped}, the absolute normalized
difference images, do show more artifacts. Now also the Joseph's projector shows clear visible
ring-like artifacts at angles around \(90^\circ\), but also multiples of \(45^\circ\) degree.
The difference between the projectors based on the blob and B-Spline basis functions show
differences. It is the most pronounced at multiples of \(45^\circ\), but in the cropped image, each
\(22^\circ\) artifacts can be seen.

\begin{figure}
	\centering

	\makebox[\textwidth]{ \makebox[1.2\textwidth]{%
			\rotatebox[x=-4.75em, y=0em]{90}{\bfseries \(45^\circ\) projection\strut}
			\begin{subfigure}{0.3\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Blob Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_Blob_48.png}}
				\phantomsubcaption{}\label{fig:sinogram_blob_3d_slice_48}
			\end{subfigure}%
			\begin{subfigure}{0.3\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Cubic B-Spline Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_BSpline_48.png}}
				\phantomsubcaption{}\label{fig:sinogram_bspline_3d_slice_48}
			\end{subfigure}%
			\begin{subfigure}{0.3\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Siddon's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_Siddon_48.png}}
				\phantomsubcaption{}\label{fig:sinogram_siddon_3d_slice_48}
			\end{subfigure}%
			\begin{subfigure}{0.3\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Joseph's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_Joseph_48.png}}
				\phantomsubcaption{}\label{fig:sinogram_joseph_3d_slice_48}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{ \makebox[1.2\textwidth]{%
			\rotatebox[x=-4.5em, y=0em]{90}{\bfseries \(180^\circ\) projection\strut}
			\begin{subfigure}{0.3\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_Blob_192.png}
				\phantomsubcaption{}\label{fig:sinogram_blob_3d_slice_192}
			\end{subfigure}%
			\begin{subfigure}{0.3\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_BSpline_192.png}
				\phantomsubcaption{}\label{fig:sinogram_bspline_3d_slice_192}
			\end{subfigure}%
			\begin{subfigure}{0.3\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_Siddon_192.png}
				\phantomsubcaption{}\label{fig:sinogram_siddon_3d_slice_192}
			\end{subfigure}%
			\begin{subfigure}{0.3\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_Joseph_192.png}
				\phantomsubcaption{}\label{fig:sinogram_joseph_3d_slice_192}
			\end{subfigure}%
		}}

	\caption{Lateral slices of the forward projector of the \(3\)d Shepp-Logan phantom of size
		\(256^3\). Top row: lateral slice of the projection of \(45^\circ\). Bottom row:
		lateral slice of the projection of \(180^\circ\). Form left to right: forward
		projections using the blob based projector, B-Spline projector, Siddon's projector
		and Joseph's projector. The blob parameters used are \(m=2\), \(\alpha=10.83\) and
		\(a=2\). The cubic B-Spline basis function are used.
	}\label{fig:3dsinogram_shepp_logan}
\end{figure}

Without repeating to much, similar artifacts can be seen in the three-dimensional case, depicted in
\autoref{fig:3dsinogram_shepp_logan}. The Siddon's method performs worst. Artefacts can be found in
the Joseph's projector, but are few and subtle. Basically no artifacts can be found in the blob
based projector. However, for the B-Spline based projector the lateral slices of the projection
\(45^\circ\) shows clear strip like artifacts. They are not visible slices for the next closest
projection angles before and after. The adjacent slices are shown in
\autoref{fig:sinogram_bspline_3d_closeup}, with the same slice again in the middle. The artifacts
are present every \(90^\circ\), i.e.\ at \(45^\circ\), \(135^\circ\), \(225^\circ\), and
\(315^\circ\). Note also, the brightness difference is remarable again.

After this discovery, I investigated further into the two-dimensional case, to see if similar
behaviour can be found. As already mentioned, \autoref{fig:sinogram_difference_blob_bspline_crop}
shows clear artifacts, these might be from the same origin. This seems to be somewhat true, however,
further investigation is necessary.

\begin{figure}
	\centering

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}{0.43\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_BSpline_47.png}}%
				\label{fig:sinogram_bspline_3d_closeup1}
			\end{subfigure}%
			\begin{subfigure}{0.43\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_BSpline_48.png}}%
				\label{fig:sinogram_bspline_3d_closeup2}
			\end{subfigure}%
			\begin{subfigure}{0.43\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection_3d/3dsinogram_BSpline_49.png}}%
				\label{fig:sinogram_bspline_3d_closeup3}
			\end{subfigure}%
		}}
	\caption{Closeup of line artifacts found at the lateral slice of the projector using cubic
		B-Spline basis functions. From left to right: slices of the projectors at
		\(44.0625^\circ\), \(45^\circ\), \(45.9375^\circ\). The parameters for the blob
		basis function are \(m=2\), \(\alpha=10.83\) and \(a=2\) and cubic B-Splines are
		used as basis function.
	}\label{fig:sinogram_bspline_3d_closeup}
\end{figure}

\section{Reconstruction of Synthetic Data}\label{sec:experiments_synthethic_projection}

After the forward projection, numerous experiments using synthetic data is presented. In total 3
different phantoms are used, ranging from simple to complex. The first phantom is just a plain
rectangle. The rectangle is centered in the image and has a constant value of \(1\) inside the
rectangle, and \(0\) everywhere else. It is included as certain artifacts are spotted with ease in
such a setting. The next phantom is the Shepp-Logan phantom~\cite{shepp_fourier_1974}. It resembles
a human head and is a standard test phantom. Due to its purely synthetic nature, it is simple to
compute error measures for reconstructions. The last phantom used is a rather complex one. It is an
example reconstruction of an human abdomen. However, the sinogram is generated from the original
image and it will be compared to it. Therefore, it is still a synthetic test, though the complexity
of the data resembles realistic medical data. All three phantoms are shown in
\autoref{fig:experiment_overview_phantoms}. Please note, that for all experiments in this section,
the inverse crime~\cite{wirgin_inverse_2004} is committed.

\begin{figure}
	\centering
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}[t]{0.40\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/phantoms/rectangle_phantom.png}
				\caption{Rectangular Phantom}\label{fig:overview_rectanglular_phantom}
			\end{subfigure}%
			\begin{subfigure}[t]{0.40\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/phantoms/shepp_logan.png}
				\caption{Shepp-Logan Phantom}\label{fig:overview_shepp_logan_phantom}
			\end{subfigure}%
			\begin{subfigure}[t]{0.40\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/phantoms/abdomen_512_normalized.png}
				\caption{Reconstruction of a lateral slice of human abdomen used as phantom}\label{fig:overview_medical_phantom}
			\end{subfigure}%
		}}
	\caption{Overview of the different phantoms used for the synthetic tests. From left to
		right: Rectangular phantom, Shepp-Logan phantom, lateral cross-section human
		abdomen. All phantoms are displayed with a windowed to values in the range
		\([0,1]\).
	}\label{fig:experiment_overview_phantoms}
\end{figure}

For all 3 phantoms the general setup is chosen to be the same. In this section only two-dimensional
reconstructions are performed. The resolution of the phantom is \(512 \times 512\) pixels. No
additional noise was added. The sinogram is computed with each projector method and a total of
\(512\) projection angles equally spaced in an \(180^\circ\) arc around the object. Note that the
\(180^\circ\) projection angle is excluded, as it would only add duplicate information already
acquired using the \(0^\circ\) projection angle. The one-dimensional detector has a resolution of
\(\lfloor 512 * \sqrt{2} \rfloor = 724\).

As the reconstructions are performed using elsa, and elsa is itself unitless, distances are given in
respect to the size of voxels.   The size of voxels is \(1\) for all dimensions. The distance from
the simulated X-ray source is \(51200\) units away from the rotation center (i.e. the center of the
volume), and the principal point of the detector is \(512\) units away.

The iterative reconstruction algorithm is \gls{FISTA}. The reconstructions for the rectangle and
Shepp-Logan phantom are run each for \(50\) iterations, and \(300\) iterations for the medical
phantom with the default regularization parameter of \(0.5\). This default regularization parameter
yielded among the best results.

As in \autoref{sec:experiments_forward_projection}, cubic B-Splines are used and the parameters for
the blob basis functions are \(m = 2\), \(\alpha = 10.83\) and \(a = 2\).

In the following sections, the experiments for each phantom are presented and directly discussed.

\subsection{Rectangular Phantom}

\begin{figure}
	\centering
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[x=-4.5em, y=0em]{90}{\bfseries Reconstruction \strut}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Blob Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_cropped_windowed_Blob.png}}
				\caption{}%
				\label{fig:rectangle_recon_artifacts_blob}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Cubic B-Spline Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_cropped_windowed_BSpline.png}}
				\caption{}%
				\label{fig:rectangle_recon_artifacts_bspline}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Siddon's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_cropped_windowed_Siddon.png}}
				\caption{}%
				\label{fig:rectangle_recon_artifacts_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Joseph's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_cropped_windowed_Joseph.png}}
				\caption{}%
				\label{fig:rectangle_recon_artifacts_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[x=-2em, y=0em]{90}{\bfseries Abs.\ Normalized Difference\strut}
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_difference_cropped_windowed_Blob.png}
				\caption{}%
				\label{fig:rectangle_recon_difference_blob}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_difference_cropped_windowed_BSpline.png}
				\caption{}%
				\label{fig:rectangle_recon_difference_bspline}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_difference_cropped_windowed_Siddon.png}
				\caption{}%
				\label{fig:rectangle_recon_difference_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_difference_cropped_windowed_Joseph.png}
				\caption{}%
				\label{fig:rectangle_recon_difference_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dphantom_rectangle.png}
				\caption{}%
				\label{fig:rectangle_recon_phantom}
			\end{subfigure}%
		}}
	\caption{\subref{fig:rectangle_recon_artifacts_blob}--\subref{fig:rectangle_recon_artifacts_joseph}
		crop of top left corner of the reconstruction rectangle with different projectors.
		The reconstruction is performed using \(50\) iterations using \gls{FISTA}. The blob
		basis function use \(m=2\), \(\alpha=10.83\) and \(a=2\) and cubic B-Splines are
		used.
		\subref{fig:rectangle_recon_difference_blob}--\subref{fig:rectangle_recon_difference_joseph}
		absolute normalized difference of reconstructed image and the phantom in
		\subref{fig:rectangle_recon_phantom}. In order from left to right and top down, the
		differences of the reconstruction using the Blob based, B-Spline, Siddon's and
		Joseph's projector and the original phantom. The window for each image is given on
		the right side for each image separately \subref{fig:rectangle_recon_phantom}
		Rectangular phantom with marked region denoting the cropped region of the images in
		\subref{fig:rectangle_recon_artifacts_blob}--\subref{fig:rectangle_recon_difference_joseph}
	}%
	\label{fig:rectangle_recon_artifacts}
\end{figure}

The reconstruction of the simple rectangular phantom is mostly useful to clearly see the artifacts
of each method. In \autoref{fig:rectangle_recon_artifacts} a crop of the reconstruction can be seen.
There, one can see both for the Siddon's and Joseph's projector ring artifacts in both the center
and the corner of the rectangle. None of these kinds of artifacts can be seen in the blob and
B-Spline based projectors. Looking at the second row with the differences images. These artifacts
are more clearly visible. Plus the edge of the rectangle is a cleaner in bot the blob and B-Spline
based projector compared to the Siddon's and Joseph's projector.

\begin{table}[h]%
	\centering
	\csvreader[
		head to column names,
		separator=semicolon,
		tabular = cccccc,
		table head = \toprule \textbf{Projector} & \textbf{\gls{MSE}} \downarrow &
		\textbf{\gls{NRMSE}} \downarrow & \textbf{\gls{PSNR}} (dB) \uparrow & \textbf{\gls{SSIM}} \uparrow \\\midrule,
		table foot = \bottomrule
	]{figures/experiments/reconstruction_rectangle/metrics.csv}{}{%
		\csvlinetotablerow%
	}
	\caption{Error metrics for the reconstruction of the rectangular phantom using 50 iterations
		of FISTA}%
	\label{tab:error_metric_rectangle}
\end{table}

The metrics discussed in \autoref{sec:error_measurements} for the reconstruction are shown in
\autoref{tab:error_metric_rectangle}. All \(l_2\) based norms (i.e. \gls{MSE}, \gls{NRMSE} and
\gls{PSNR}) are lower for the projectors based on Siddon's and Joseph's method. But all of them are
quite close to each other (around \num{1e-4} for \gls{MSE}). Notably, they are all in the same order
of magnitude. A similar observation can be made for \gls{SSIM}, only the Siddon's method falls
behind a bit.

\subsection{Shepp-Logan Phantom}

\begin{figure}
	\centering
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[x=-4.5em, y=0em]{90}{\bfseries Reconstruction\strut}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Blob Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_windowed_Blob.png}}
				\caption{}\label{fig:reconstruction_shepp_logan_blob}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Cubic B-Spline Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_windowed_BSpline.png}}
				\caption{}\label{fig:reconstruction_shepp_logan_bspline}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Siddon's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_windowed_Siddon.png}}
				\caption{}\label{fig:reconstruction_shepp_logan_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Joseph's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_windowed_Joseph.png}}
				\caption{}\label{fig:reconstruction_shepp_logan_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\rotatebox[x=-2em, y=0em]{90}{\bfseries Abs.\ Normalized Difference\strut}
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_difference_cropped_windowed_Blob.png}
				\caption{}\label{fig:reconstruction_shepp_logan_cropped_blob}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_difference_cropped_windowed_BSpline.png}
				\caption{}\label{fig:reconstruction_shepp_logan_cropped_bspline}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_difference_cropped_windowed_Siddon.png}
				\caption{}\label{fig:reconstruction_shepp_logan_cropped_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_difference_cropped_windowed_Joseph.png}
				\caption{}\label{fig:reconstruction_shepp_logan_cropped_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dphantom_rectangle.png}
				\caption{}\label{fig:rectangle_shepp_logan_phantom}
			\end{subfigure}
		}}

	\caption{\subref{fig:reconstruction_shepp_logan_blob}--\subref{fig:reconstruction_shepp_logan_joseph}
		Reconstruction of the Shepp-Logan phantom using the (from left to right) the
		projectors using the blob and B-Spline basis function followed by the projector
		based on the Siddon's and Joseph's method. The reconstruction is performed using
		\(50\) iterations of \gls{FISTA}. The parameters for the blob basis function are
		\(m=2\), \(\alpha=10.83\) and \(a=2\) and cubic B-Splines are used as basis
		function.
		\subref{fig:reconstruction_shepp_logan_cropped_blob}--\subref{fig:reconstruction_shepp_logan_joseph}
		crop into the difference of each reconstruction with the original phantom, the same
		order of projectors is given. The window is given for each image individually.
		\subref{fig:rectangle_shepp_logan_phantom} the original phantom including a red
		rectangle indicating the cropped region.
	}%
	\label{fig:reconstruction_shepp_logan}
\end{figure}

The reconstruction for the Shepp-Logan phantom is shown in figure
\autoref{fig:reconstruction_shepp_logan}. The top row shows the final reconstruction, the middle row
a crop into the difference image, and the bottom shows complete phantom with cropped region marked.
For the first two rows the reconstruction are performed using (from left to right) the projector
using the blob basis function, the B-Spline basis function, the Siddon's method and the Joseph's
method.

As expected, the Siddon's method shows clear ring artifacts (best seen in
\autoref{fig:reconstruction_shepp_logan_siddon}). They are also present in the Joseph's method, but
they stand out less. Finally, both projectors based on the blob and B-Spline basis functions show no
sign of ring artifacts. Neither in the first row, nor in the cropped difference image.

\begin{table}[h]%
	\centering
	\csvreader[
		head to column names,
		separator=semicolon,
		tabular = cccccc,
		table head = \toprule \textbf{Projector} & \textbf{\gls{MSE}} \downarrow &
		\textbf{\gls{NRMSE}} \downarrow & \textbf{\gls{PSNR}} \uparrow & \textbf{\gls{SSIM}} \uparrow \\\midrule,
		table foot = \bottomrule
	]{figures/experiments/reconstruction_shepp_logan/metrics.csv}{}{%
		\csvlinetotablerow%
	}
	\caption{Error metrics for the reconstruction of the Shepp-Logan phantom running for \(50\)
		iterations of FISTA.}%
	\label{tab:error_metric_shepp_logan}
\end{table}

The metrics for the reconstruction are listed in \autoref{tab:error_metric_shepp_logan}.
Interestingly, the visually worst reconstruction (Siddon's one), performs best regarding \(l_2\)
based metrics (i.e.\ \gls{MSE}, \gls{NRMSE} and \gls{PSNR}). However, the bad visual perception is
backed up by the \gls{SSIM}. The Siddon's method performs even worse (around \(8\%\) compared to
both the blob and B-Spline one), and both the blob and B-Spline based projector can outperform the
Joseph's projector. Though against the latter one, it is a small difference.

\subsection{Human Abdomen}

\begin{figure}
	\centering
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[x=-4.5em, y=0em]{90}{\bfseries Reconstruction\strut}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Blob Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_medical/2dreconstruction_windowed_Blob.png}}
				\caption{}\label{fig:reconstruction_medical_blob}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Cubic B-Spline Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_medical/2dreconstruction_windowed_BSpline.png}}
				\caption{}\label{fig:reconstruction_medical_bspline}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Siddon's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_medical/2dreconstruction_windowed_Siddon.png}}
				\caption{}\label{fig:reconstruction_medical_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Joseph's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_medical/2dreconstruction_windowed_Joseph.png}}
				\caption{}\label{fig:reconstruction_medical_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\rotatebox[x=-2em, y=0em]{90}{\bfseries Abs.\ Normalized Difference\strut}
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_medical/2dreconstruction_difference_cropped_windowed_Blob.png}
				\caption{}\label{fig:reconstruction_medical_cropped_blob}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_medical/2dreconstruction_difference_cropped_windowed_BSpline.png}
				\caption{}\label{fig:reconstruction_medical_cropped_bspline}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_medical/2dreconstruction_difference_cropped_windowed_Siddon.png}
				\caption{}\label{fig:reconstruction_medical_cropped_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_medical/2dreconstruction_difference_cropped_windowed_Joseph.png}
				\caption{}\label{fig:reconstruction_medical_cropped_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_medical/abdomen_512_normalized_rectangle.png}
				\caption{}\label{fig:medical_phantom_marked}
			\end{subfigure}
		}}

	\caption{\subref{fig:reconstruction_medical_blob}--\subref{fig:reconstruction_medical_joseph}
		Reconstruction of the medical phantom using the different projectors as a basis. It
		is performed using \(300\) iterations of \gls{FISTA}. From left, to right: the
		projector based on the blob basis, B-Spline basis, Siddon's method and finally
		Joseph's method. The parameters for the blob basis function are \(m=2\),
		\(\alpha=10.83\) and \(a=2\) and cubic B-Splines are used as basis function. The
		second row
		\subref{fig:reconstruction_medical_blob}--\subref{fig:reconstruction_medical_joseph}
		shows a crop into the difference image to the phantom data. The reconstructed image
		used the same projector as the reconstruction in the row above.
		\subref{fig:medical_phantom_marked} the original phantom including a red rectangle
		indicating the cropped region.
	}%
	\label{fig:reconstruction_medical}
\end{figure}

The final phantom taken into account is the reconstruction of the human abdomen. The reconstruction
is shown in \autoref{fig:reconstruction_medical}. After the \(300\) solver iterations, all
reconstructions look decent. However, no great difference can be seen on this scale. Looking at the
cropped images in the second row of \autoref{fig:reconstruction_medical}, one can see that the new
projectors are cleaner compared especially to Siddon's based projector. Interestingly, the window
interval is a touch --- but notably --- higher for both the blob and B-Spline basis functions. For
such a complex phantom, the difference seems to vanish.

\begin{table}[h]%
	\centering
	\csvreader[
		head to column names,
		separator=semicolon,
		tabular = cccccc,
		table head = \toprule \textbf{Projector} & \textbf{\gls{MSE}} \downarrow &
		\textbf{\gls{NRMSE}} \downarrow & \textbf{\gls{PSNR}} \uparrow & \textbf{\gls{SSIM}} \uparrow \\\midrule,
		table foot = \bottomrule
	]{figures/experiments/reconstruction_medical/metrics.csv}{}{%
		\csvlinetotablerow%
	}
	\caption{Error metrics for the reconstruction of the medical phantom using FISTA running for
		\(300\) iterations}%
	\label{tab:error_metric_medical}
\end{table}

The \gls{SSIM} (right-most column in \autoref{tab:error_metric_medical}) for the blob based
projector is significantly lower compared to the other methods. The \(l_2\) based norms only show a
slightly worse performance of the blob based projector. This behaviour is consistent over multiple
runs of this experiment. Apart from this, the metric for the other methods also indicate less
influence of the exact forward model. However, the cubic B-Spline based projector still manages to
consistently outperform both the Siddon's and Joseph's projector in regards to all metrics used.

\subsection{Behavior in the Presence of Noise}

Another interesting case is a detailed experiment with noisy data. The medical phantom already
provided a sample including noise. But there, it is ingrained in the phantom and hence can not be
analyzed independently. For this experiment, the same overall setup was used as for the Shepp-Logan
phantom in the previous section, but additionally \(1\%\) of Gaussian noise is added to the sinogram
before the reconstruction process starts. I.e.\ the mean of the Gaussian is \(0\) and the standard
deviation is set to be \(1\%\) of the value range of the sinogram. Further, the reconstruction is
run for \(150\) iterations, instead of \(50\). All the other parameters are set exactly as in the
above case.

\begin{figure}
	\centering
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[x=-4.5em, y=0em]{90}{\bfseries Reconstruction\strut}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Blob Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_noise/2dreconstruction_windowed_Blob.png}}
				\caption{}\label{fig:reconstruction_noise_blob}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Cubic B-Spline Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_noise/2dreconstruction_windowed_BSpline.png}}
				\caption{}\label{fig:reconstruction_noise_bspline}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Siddon's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_noise/2dreconstruction_windowed_Siddon.png}}
				\caption{}\label{fig:reconstruction_noise_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{\bfseries Joseph's Projector\strut}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_noise/2dreconstruction_windowed_Joseph.png}}
				\caption{}\label{fig:reconstruction_noise_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\rotatebox[x=-2em, y=0em]{90}{\bfseries Abs.\ Normalized Difference\strut}
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_noise/2dreconstruction_difference_cropped_windowed_Blob.png}
				\caption{}\label{fig:reconstruction_noise_cropped_blob}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_noise/2dreconstruction_difference_cropped_windowed_BSpline.png}
				\caption{}\label{fig:reconstruction_noise_cropped_bspline}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_noise/2dreconstruction_difference_cropped_windowed_Siddon.png}
				\caption{}\label{fig:reconstruction_noise_cropped_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_noise/2dreconstruction_difference_cropped_windowed_Joseph.png}
				\caption{}\label{fig:reconstruction_noise_cropped_joseph}
			\end{subfigure}%
		}}
	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_noise/2dphantom_rectangle.png}
				\caption{}\label{fig:phantom_noise_marked}
			\end{subfigure}
		}}

	\caption{\subref{fig:reconstruction_noise_blob}--\subref{fig:reconstruction_noise_joseph}
		Reconstruction of the Shepp-Logan phantom, when \(1\%\) of Gaussian noise is added
		to the sinogram. \(150\) iterations of \gls{FISTA} are used for the reconstruction.
		From left, to right: the projector based on the blob basis, B-Spline basis, Siddon's
		method and finally Joseph's method. The parameters for the blob basis function are
		\(m=2\), \(\alpha=10.83\) and \(a=2\) and cubic B-Splines are used as basis
		function. The second row
		\subref{fig:reconstruction_noise_cropped_blob}--\subref{fig:reconstruction_medical_cropped_joseph}
		shows a crop into the difference image to the phantom data. The reconstructed image
		used the same projector as the reconstruction in the row above.
		\subref{fig:phantom_noise_marked} the original phantom including a red rectangle
		indicating the cropped region.
	}%
	\label{fig:reconstruction_noise}
\end{figure}

Both the blob and B-Spline based projectors handle Gaussian noise nicely, as it can be seen in
\autoref{fig:reconstruction_noise}. They do show some form of artifacts, but that is to be expected
in the presence of noise. The center ellipses are quite clean and the top most circle shows some
artifacts. However, it is quite a bit better controlled than the Siddon's and Joseph's method.

\begin{table}[h]%
	\centering
	\csvreader[
		head to column names,
		separator=semicolon,
		tabular = cccccc,
		table head = \toprule \textbf{Projector} & \textbf{\gls{MSE}} \downarrow &
		\textbf{\gls{NRMSE}} \downarrow & \textbf{\gls{PSNR}} \uparrow & \textbf{\gls{SSIM}} \uparrow \\\midrule,
		table foot = \bottomrule
	]{figures/experiments/reconstruction_noise/metrics.csv}{}{%
		\csvlinetotablerow%
	}
	\caption{Error metrics for the reconstruction of the noisy Shepp-Logan phantom using FISTA
		running for \(150\) iterations}%
	\label{tab:error_metric_noise}
\end{table}

This is also backed up by the error metrics given in \autoref{tab:error_metric_noise}. Both the blob
and B-Spline basis function based projectors perform better according to the \gls{SSIM}. And with a
decent lead as that as well. Again they are both worse in the \gls{MSE} based metrics, but just a
bit at that.

\section{Quality Summary}\label{sec:experiments_quality_projection}

This section is a summary of the already discussed qualitative impression. As expected from the
literature, Siddon's method performs the worst among the methods compared. It shows clear
high-frequency artifacts in both the forward projection and the final reconstruction. In the forward
projection it is performs specifically bad at angles around each \(90^\circ\). Furthermore, it
poorly handles noise. It should be noted however, that the Siddon's method performs equally well or
sometimes better than the other methods if one only looks at the \(l_2\) based error metrics
(\gls{MSE}, \gls{NRMSE} and \gls{PSNR}).

The Joseph's projector performs better. Is shows less artifacts in the forward projector, the
reconstructions are cleaner and noise is handled better. Throughout the tests, it performs basically
identically in all \(l_2\) based error metrics, and beats the Siddon's method regarding the
\gls{SSIM} in all experiments.

Both the blob and B-Spline based projector outperform the Siddon's and Joseph's based projectors.
The blob based projector does not have any visible artifacts in the forward projection. The B-Spline
based projector exhibits artifacts for multiples of the \(45^\circ\) projection angle in the
three-dimensional case. However, it seems to be the only affected projection angle. On the other
hand, the blob base projector --- according to the error metrics --- has a significant drop in
quality in the reconstruction of the human abdomen. No explanation could be found for this drop, but
it is consistent with multiple independent runs of the experiment. Also this drop does not reflect
the visual inspection. Further, both methods perform well in the presence of added noise to the
forward projection.

\section{Performance Overview}\label{sec:experiments_performance_projection}

To investigate the runtime performance characteristics of the blob and B-Spline based projectors two
experiments are conducted. One for the two-dimensional and the other for the three-dimensional case.
The experiments run either the forward or the backward projector in a tight loop for a fixed number
of times. For the benchmarking of the forward projection, the phantom is generated once and then
reused for each iteration. For the backward projection, the sinogram is computed once and then
reused. After each iterator the elapsed time is stored and the next iteration is started. To ensure
both data and code is in cache, 2 warm-up iterations are run. For both dimensions, only the size of
the original phantom changes. The number of projection positions is kept the same, to ensure only
the phantom size induces changes in the runtime.

The two-dimensional case uses a constant \(512\) projections positions and \(50\) iterations to
ensure a large enough sample size. Phantom sizes range from \(64 \times 64\) to \(512 \times 512\).
In the three-dimensional case, only \(64\) projection positions are used, the phantom sizes range
from \(32 \times 32 \times 32\) to \(64 \times 64 \times 64\) and only \(25\) iterations are run.

The same parameters for the basis function are used as with the other experiments. Importantly for
this section, both basis functions have a support of \(2\) units.

The experiments are run on a machine equipped with an AMD Ryzen 7 3700X with \(8\) cores, \(16\)
threads. The experiments are performed an all \(16\) threads. The CPU has a base clock of \(3.6\)
GHz, but is able to boost up to \(4.4\) GHz under load. The system has \(16013\) MiB of main memory
and the operating system is Linux based, running the '5.10.105-1-MANJARO` kernel. As much as
possible background tasks are closed during the benchmarks and the machine is left running until
finished without any user interaction.

\begin{table}[h]%
	\centering
	\csvreader[
		head to column names,
		separator=semicolon,
		tabular = cccccc,
		table head = \toprule \textbf{Dimension} & \textbf{Siddon} & \textbf{Joseph} \downarrow &
		\textbf{B-Spline based} \downarrow & \textbf{Blob based} \downarrow \\\midrule,
		table foot = \bottomrule
	]{figures/experiments/perf_testing/speedup.csv}{}{%
		\csvlinetotablerow%
	}
	\caption{Mean runtime slowdown over all compared sizes of the different projector methods,
		with the Siddon's projector as a baseline. The slowdown is the average over all the
		different experiment sizes. The first row shows the slow down for the
		two-dimensional case and the second row, for the three-dimensional case.}%
	\label{tab:runtime_slowdown}
\end{table}

\autoref{tab:runtime_slowdown} summaries the performance results. The results are given as slow
downs compared to the Siddon's projector. Hence, the B-Spline and Blob based projector are around
\(6\) to \(7\) times slower than the Siddon projector in the two-dimensional case. This is inline
with the finding of \citeauthor*{momey_b-spline_2012}~\cite{momey_b-spline_2012} (though they
compare against the distance-driven projector).

The performance drop for the three-dimensional case is close to another \(6\) times slowdown. But as
the number of visited voxels grows from \(5\) visited voxels to \(25\) in the three-dimensional
case, this is only to be expected.

In \autoref{fig:performance_2d_lineplot} the mean runtime and the standard deviations of each
benchmark is plotted for the two-dimensional case and in \autoref{fig:performance_3d_lineplot} for
the three-dimensional. Noticeably, the methods scale similarly to both the Siddon's and Joseph's
method, but the performance drop can be seen here as well.

\begin{figure}
	\centering

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			% \rotatebox[origin=c]{90}{\bfseries Zoom into difference\strut}
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_2d_line_forward.png}
				\caption{Runtime for the \(2\)d-forward projection}\label{fig:performance_2d_lineplot_forward}
			\end{subfigure}%
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_2d_line_backward.png}
				\caption{Runtime for the \(2\)d-backward projection}\label{fig:performance_2d_lineplot_backward}
			\end{subfigure}%
		}}

	\caption{Runtime in seconds for the 4 different projection methods, both for the forward
		projection \subref{fig:performance_2d_lineplot_forward} and backward
                projection \subref{fig:performance_2d_lineplot_backward}. The lightly shaded area
                around the line plot shows the tolerance interval based on the standard deviation of
                the samples for each size. Both axis use a base 2 logarithmic scale. Number of
                angles is fixed to \(512\) for all experiments.}%
	\label{fig:performance_2d_lineplot}
\end{figure}

\begin{figure}
	\centering

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			% \rotatebox[origin=c]{90}{\bfseries Zoom into difference\strut}
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_3d_line_forward.png}
				\caption{Runtime for the \(3\)d-forward projection}\label{fig:performance_3d_lineplot_forward}
			\end{subfigure}%
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_3d_line_backward.png}
				\caption{Runtime for the \(3\)d-backward projection}\label{fig:performance_3d_lineplot_backward}
			\end{subfigure}%
		}}

	\caption{Runtime seconds for the 4 different projection methods, both for the
		three-dimensional forward projection \subref{fig:performance_2d_lineplot_forward}
		and backward projection \subref{fig:performance_2d_lineplot_backward}. Lightly
		shaded area around the line plot shows the tolerance interval based on the standard
		deviation of the samples for each size. Both axis use a base 2 logarithmic scale.
		Number of angles is fixed to \(512\) for all experiments.}%
	\label{fig:performance_3d_lineplot}
\end{figure}

\autoref{fig:performance_2d_violin_forward} and \autoref{fig:performance_2d_violin_backward} show a
detailed break down of the two-dimensional measurements from the previous plots. They are split into
the forward and backward projection and each projector has an individual plot. The blob and B-Spline
based projectors performance is quite consistent compared to the Siddon's and Joseph's, i.e.\ they
have only few outliers.

\begin{figure}
	\centering

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			% \rotatebox[origin=c]{90}{\bfseries Zoom into difference\strut}
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_2d_violin_forward_Blob.png}
				\caption{}\label{fig:performance_2d_violin_forward_blob}
			\end{subfigure}%
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_2d_violin_forward_BSpline.png}
				\caption{}\label{fig:performance_2d_violin_forward_bspline}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			% \rotatebox[origin=c]{90}{\bfseries Zoom into difference\strut}
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_2d_violin_forward_Siddon.png}
				\caption{}\label{fig:performance_2d_violin_forward_siddons}
			\end{subfigure}%
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_2d_violin_forward_Joseph.png}
				\caption{}\label{fig:performance_2d_violin_forward_joseph}
			\end{subfigure}%
		}}

	\caption{Violin plot for the forward projection of a selection of the sizes, individually
		given for the different projectors. Plot for the blob based projector
		\subref{fig:performance_2d_violin_forward_blob} B-Spline based
		\subref{fig:performance_2d_violin_forward_bspline}, Siddon's
		\subref{fig:performance_2d_violin_forward_siddons} and Joseph's
                \subref{fig:performance_2d_violin_forward_joseph}. The median is given as the white
                line, the thicker line is the inter-quantile range, the thin bars give the minimum
                and maximum respectively and the points outside of the minimum and maximum are the
                outliers. \(y\)-axes is in logarithm scale.}%
	\label{fig:performance_2d_violin_forward}
\end{figure}

Interestingly, the performance characteristics of most of the runs seem to lie between two extremes.
As it can be seen in \autoref{fig:performance_2d_violin_forward}, for most sizes and methods
regarding the forward projection. Only few of the distributions lie around the mean. This indicates
a behaviour, were two cases are hit, in one, the projector finishes quickly, in the other it takes a
while. No exact explanation for this behaviour can be given at this point. This is in contrast to
the back-projection see in detail in \autoref{fig:performance_2d_violin_backward}. There the
distribution of most sizes is around the median.

\begin{figure}
	\centering

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			% \rotatebox[origin=c]{90}{\bfseries Zoom into difference\strut}
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_2d_violin_backward_Blob.png}
				\caption{}\label{fig:performance_2d_violin_backward_blob}
			\end{subfigure}%
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_2d_violin_backward_BSpline.png}
				\caption{}\label{fig:performance_2d_violin_backward_bspline}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			% \rotatebox[origin=c]{90}{\bfseries Zoom into difference\strut}
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_2d_violin_backward_Siddon.png}
				\caption{}\label{fig:performance_2d_violin_backward_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/perf_testing/plot_2d_violin_backward_Joseph.png}
				\caption{}\label{fig:performance_2d_violin_backward_joseph}
			\end{subfigure}%
		}}

	\caption{Violin plot for the backward projection of a selection of the sizes, individually
		given for the different projectors. Plot for the blob based projector
		\subref{fig:performance_2d_violin_forward_blob} B-Spline based
		\subref{fig:performance_2d_violin_forward_bspline}, Siddon's
		\subref{fig:performance_2d_violin_forward_siddons} and Joseph's
		\subref{fig:performance_2d_violin_forward_joseph}. The median is given as the white
                line, the thicker line is the inter-quantile range, the thin bars give the minimum
                and maximum respectively and the points outside of the minimum and maximum are the
                outliers. \(y\)-axes is in logarithm scale.}%
	\label{fig:performance_2d_violin_backward}
\end{figure}

Overall, the increased accuracy of the new projectors comes at a cost. In the two-dimensional
settings this cost is worth considering in certain scenarios, where quality and accuracy is of great
importance. However, the additional runtime performance for the three-dimensional case is huge. This
is a factor, where multiple additional iterations of an solving algorithm can be run, which has a
major effect on the quality of a reconstruction.
