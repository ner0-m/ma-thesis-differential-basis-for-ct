\chapter{elsa}\label{chap:elsa}

I want to dedicate a chapter to the C++ framework elsa~\cite{lasser_elsa_2019} developed at the
\gls{CIIP} research group. As the practical part of my thesis is implemented for elsa, I feel that a
short introduction is more than appropriated. But, throughout the last 5 years , I've mostly been
working on either elsa, or the predecessor of it. Hence, I also like this to be a part of this
thesis for personal reasons.

elsa is a modern, flexible and open-source framework for tomographic reconstruction. I consider elsa
to have three important goals. First, and maybe most importantly for the user side, it should be
close the either mathematical notation, or at least mathematical concepts, second, it should be
useful for the research done at the \gls{CIIP} research group and finally, it should be as easy as
possible for other to reproduce results from the research.

elsa is able to handle general optimization problems of the form
\[ \argmin_{\mvec{c}} \quad T(A, \mvec{c}, \mvec{m}) + \sum_{k=1}^K \lambda_k R_k(\mvec{c}) \]
where \(T\) is the data fidelity term depending on the forward model \(A\), the solution
\(\mvec{c}\), and the measurements \(\mvec{m}\), \(K\) penalty or regularization terms depending on
\(\mvec{c}\) and \(\lambda_k\) is a regularization parameter for the \(k\)th penalty term (compare
\autoref{def:regularized_problem} with a single penalty term).

Building the framework around this general problem statement enables the implementation of multiple
imaging modalities in one framework. Currently, only X-ray attenuation CT is implemented. However,
from a theoretical standpoint other modalities such as phase-contrast CT, (anisotropic) dark-field
CT can be incorporated. Plus many aspects of the framework are independent of the specific
application, and reusable. I.e\ one needs no different implementation of algorithms solving the
above given equations such as \gls{ART}, or \gls{ISTA}\@.

This is a key difference between other frameworks such as the ASTRA
Toolbox~\cite{van_aarle_fast_2016}, TIGRE~\cite{biguri_tigre_2016} or
FreeCT~\cite{hoffman_technical_2016}. Though there are frameworks supporting multiple imaging
modalities, they are not general enough for the research at the \gls{CIIP} research group.

From a software engineering standpoint, a lot of effort is put into reproducibility, maintenance and
correctness, by following as many different best practices as we can and see fit. This includes
having an extensive unit testing suite (though, we can still improve there), a merge request based
workflow, which heavily relies on continuous integration, and as much as possible, we follow modern
C++ guidelines and rely on modern features from C++17. Further, to ease prototyping and improve
accessibility Python bindings are provided as well.

The general architecture is is build in a couple of layers. At the bottom, all data handling is done
by the \mintinline{cpp}{DataContainer} class. It is the one type to store and handle all
\(n\)-dimensional data in the framework. It handles storage for data accessible by the \gls{CPU} and
the \gls{GPU} and transfers between those two. Further, it leverages expression templates to reduce
the general memory footprint of applications. Above that, the mathematical concepts are implemented.
This includes concepts for residuals, functionals (such as \(l_1\), \(l_2\), or the Huber norm) and
linear operators (modeling both the forward models and operators such as scaling or finite
differences). Finally, it also includes an abstraction for the different algorithms solving
optimization problems.

Currently, two different forward models are implemented for X-ray attenuation CT. Both have a
\gls{CPU} and \gls{GPU} (specifically NVidia's CUDA) version available, as the forward and backward
projection are usually the computationally most expensive. The specific implemented methods are
referred to as Siddon's and Joseph's method, see the next \autoref{chap:projector} for a details.

I will refer the interested reader to
\href{https://gitlab.lrz.de/IP/elsa/}{https://gitlab.lrz.de/IP/elsa/}. There, one can find guides to
install and use elsa extensively, plus examples.

\chapter{Projector}\label{chap:projector}

As shown in previous chapters, calculation of the system matrix coefficients is one of the key
components of tomographic reconstruction. Thus, this has been an important part of research. The
routines or algorithms, which calculate the matrix are usually referred to as projectors. For the
forward projection, the contribution of each voxel to each detector pixel is calculated. For the
backward projection, the contribution of each detector pixel each a voxel is computed.

In the first part of this chapter, a detailed overview over existing research and implementations of
projectors is given. Next details on the projector used for this thesis is given. This is followed
by a detailed studied of accuracy and performance of the new projector compared to other projection
methods.

\section{Types of Projectors}\label{sec:projector_types}

One of the first mentions of projector routines can be found in the RECLBL library package
\insertref{RECLBL}. Namely, the two types of projectors introduced there are the
\textit{voxel-driven} (or \textit{pixel-driven} for the 2D case) and the \textit{ray driven}. Many
state of the art projectors still build on the ideas of these projectors.

The voxel driven approach is very simple. For the forward projection, each voxel is visited and the
voxel center is projected onto the detector. Finally, the contribution of the voxel to the detector,
is computed using some form of interpolation.~\cite{peters_algorithms_1981} used bilinear
interpolation between the two neighbouring detector pixels.~\cite{harauz_interpolation_1983}
improved on the approach by using bicubic spline interpolation. However, the approach is used rarely
due to the introduced artifacts (C.f.~\cite[Chapter 3.3]{levakhina_three-dimensional_2014}). I.e. if
the resolution of the detector is finer compared to the volume, detector pixels might never be
assigned a value. \todo{describe back projector properly as well}

Instead of projecting the voxel center and interpolating, one can project the complete voxel onto
the projector plane. This approach was taken by~\cite{long_3d_2010, long_3d_nodate} and is usually
referred to as separable footprint. They use trapezoidal functions to approximate the footprint both
accurately and efficiently. Hence, the contribution of voxels to the detector pixels is based on
these trapeziodial functions. It as also been ported to \gls{GPU} as shown in ~\cite{wu_gpu_2011,
	xie_effective_2015, chapdelaine_new_nodate}. To the best of my knowledge, for voxel based
approaches, this is the state of the art approach and outperforms other approaches.

This approach was translated to B-Splines in~\cite{momey_b-spline_2012, momey_spline_2015}. There
B-Splines are assumed to be the basis function at pixel centers, and then the B-Splines are
projected onto the projector plane. As shown in chapter about B-Spline basis functions
\insertref{B-Spline chapter}, the projection of \(n\)-dimensional B-Splines yield a
\(n-1\)-dimensional B-Spline, hence the projection is simple and
accurate.~\cite{momey_b-spline_2012} already incorporated both parallel-beam and cone-beam
geometry.

Similarly,~\cite{ziegler_efficient_2006} proposed a footprint approach for blobs. And it was
improved and ported to the \gls{GPU} by~\cite{bippus_projector_2011}.~\cite{kohler_iterative_2011}
describes a blob projector for phase-contrast CT\@.

A shared problem of the voxel-based approaches, is the challenge of parallel implementations. During
the forward projectiong, shared access to the projector pixels might be needed. Hence, mitigation
strategies must be developed.

A conceptually different approach compared to the voxel-based approach, is the \textit{ray-based}
approach. There, the key idea is to trace rays through the volume. Typically, the intersection
length is used as a contribution of a pixel to the detector pixel.

Note that this the forward projection of this approach, is trivially parallisable. Each ray can be
traced independently through the volume.

A classical ray-driven approach was proposed by~\cite{siddon_fast_1985}, often is is referred to as
Siddon's method. There, the exact path length of a ray traversing through a volume is calculated.
I.e.\, this is the exact calculation of the line integral of a single ray through the volume. More
recent work like~\cite{jacobs_fast_1998, christiaens_fast_1999, zhao_fast_2004, gao_fast_2012}
improved on the Siddon's method, especially in efficiency and
performance.~\cite{de_greef_accelerated_2009, xiao_efficient_2012} ported Siddon's methods to the
\gls{GPU}\@.

\begin{figure}[H]
	\centering
	% Taken from https://tex.stackexchange.com/a/398309
	\includegraphics[width=\textwidth]{./figures/projectors_siddon/siddon_traversal.png}
	\caption{Visualization of Siddon's method. Siddon's method exactly computes the intersection
		length of each voxel (text inside each voxel) with a ray (cardinal red line), which
		is used as a weight for the forward and backward projections. The intersection
		length for each voxel is given by the distance between the points where the ray
		enters and exists each voxel (marked as black
		dots).}\label{fig:visualization_siddon_traversal}
\end{figure}

Another classic is presented in~\cite{joseph_improved_1982}. It assumes a smooth image and
interpolates between neighbouring voxels along the ray path. It does so by a in slice-interpolation,
i.e.\ the voxels perpendicular to the main ray direction are visited.~\cite{graetz_high_2020}
proposed a branchless \gls{GPU} version of this approach.

The backward projections of ray-driven approaches typically trace the ray from a detector pixel to
the source and update all visited voxels based on the weights calculated as in the forward
direction. And in the of Joseph's based methods, also voxels close by are updated. Note again here,
that parallelization is hindered by the possibility of shared write access to voxels.

Typically, iterative reconstruction algorithms expect that the forward and backward projectors are
adjoints of each other \insertref{forward and backward projectors are adjoints}, i.e.\ they are
\textit{matched} projector pair. This fails for basic pixel- and ray-driven approaches.
They either either introduce artifacts during the forward or backward projections.

An entirely different approach is the \textit{distance-driven} approach
~\cite{de_man_distance-driven_2002, de_man_distance-driven_2004}. There, the voxel boundaries and
detector pixel boundaries are projected onto a common axis, then the overlap is used as a weight.
This approach is still state of the art, however, is suffers from inaccuracys for projections, which
are close to 45°. A branchless \gls{GPU} version was proposed in~\cite{liu_gpu-based_2017}. The
distance-driven approach doesn't suffer from any high-frequency artifacts.

Projectors based on blobs have been studied for quite some time. Ray-driven approaches are based on
algorithms proposed in~\cite{matej_practical_1996, popescu_ray_2004}. But rather than assuming a
infinitely thin ray, they assume a beam. Hence, they are somewhat similar to Joseph's projectors,
that they have to visit neighbouring voxels, as the support of blobs is larger than that of pixels.
~\cite{levakhina_distance-driven_2010} proposed a variant of the distance-driven approach based on
blobs.

Another area of projectors compute the intersection area of multiple rays. Such methods, as proposed
in~\cite{ha_study_2015, ha_efficient_2016, ha_look-up_2018}, calculate the intersection between rays
directed a detector boundaries.

\section{Implementation of Differentiable Projection Operators}\label{sec:implementation}

The forward model is implemented elsa, and can be found in the master branch. This section covers
first a general overview of the algorithm, plus some details on the implementation. Recall the
definition of image from \autoref{def:image}, this method works for both \(2\) and \(3\) dimensional
images, however, to avoid repetition I will only talk about images and refer to both.

For both the forward and backward projection, the implemented algorithm can be categorized as a
ray-driven approach. I.e.\ it traverses each ray through the image going form all the poses defined
to each detector pixel.

Given a ray, the first step is a quick intersection test of the ray and the bounding box of the
image. If the ray hits the bounding box, it needs to traverse the regular spaced grid of the image.
The specific traversal algorithm is based on~\cite{amanatides_fast_1987}, however it is simplified.
In \autoref{fig:visualization_siddon_traversal} the steps the algorithm would take can be seen. It
ensures, each voxel is visited, even if it is only for a small amount.

For the purpose of this projector, however, the basis functions considered have a support larger
than a single voxel. Hence, the previous algorithm can be simplified to traverse in a
\textit{slice-by-slice} fashion. Specifically, this means, that the algorithm only steps a fixed
width in the leading direction of the given ray. The voxels visited this way are referred to here as
\textit{center voxels}, as they are the center of the a given slice. Then for each center voxel, the
neighbouring voxels perpendicular to the leading direction are visited for a given distance. The
distance depends on the specific choice of basis function and their parameters. This is depicted in
\autoref{fig:visualization_slice_traversal}.

\begin{figure}[H]
	\centering
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/projectors_slice/slice_traversal.png}
				\caption{}\label{fig:visu_slice_traver_a}%
			\end{subfigure}%
			\begin{subfigure}{0.65\textwidth}
				\includegraphics[width=\textwidth]{./figures/projectors_slice/slice_traversal_clean.png}
				\caption{}\label{fig:visu_slice_traver_b}%
			\end{subfigure}
		}}
	\caption{\subref{fig:visu_slice_traver_a} Visualization of the voxels visited
		for the slice traversal. The ray (cardinal red line) traverses the image. For each
		center voxel (darker blue), neighbour voxels (light blue) perpendicular to the
		leading direction (here the x-direction) are visited for a certain distance (here
		the distance is \(1\)). The center voxels are traversed from closer to the ray
		origin, in this visualization on the left, going to the right. The dotted black
		lines indicate the perpendicular distance from the voxel center to the ray.
		\subref{fig:visu_slice_traver_b} same setting as in
		\subref{fig:visu_slice_traver_a}, however, the support of the a basis function is
		depicted (black circle), only for a single slice. There the intersection between the
		ray and the circle is the Radon Transform of the ray and the contribution of the
		basis function to the projection.
	}\label{fig:visualization_slice_traversal}
\end{figure}

The next important part of the projector is the evaluation of the weight for each visited voxel.
Looking at \autoref{fig:visualization_slice_traversal}, the dotted black lines indicate the
distances from the voxel center to the ray. These distances are used to compute the Radon Transform
of the given basis function.

In the case of blob basis functions, the closed form solution given in \autoref{eq:radon_blob_basis}
is used with \(r\) being exactly the distance just mentioend. In the case of B-Splines it is just a
touch more complicated. As explained in \autoref{sec:bspline_basis}, the projected B-Spline are
again B-Splines. However, B-Splines are not perfectly spherically symmetric. But they are close
enough to assume it (compare~\cite{momey_b-spline_2012, momey_spline_2015} for specifics) Hence, it
is assumed that the B-Spline are spherically symmetric, and therefore the evaluation (and using
their separability) simplifies to
\[ \radon\beta^d(r) = \beta^d(r) \prod^{n - 1}_{k=1} \beta^d(0) \]
For both basis functions, a \gls{LUT} is computed first for the creation of the projector, and the
for the actual projections the values are looked up.

The same traversal and evaluation methods are used for both the forward and backward projection, and
hence no further disuccsion is needed there. However, one more point should be noted for the sake of
completeness. As \citeauthor*{momey_spline_2015}~\cite{momey_spline_2015} showed for B-Splines and
\citeauthor*{kohler_iterative_2011}~\cite{kohler_iterative_2011} for blobs, it is possible to use
footprints instead of a ray-driven approach for both basis functions. The only reason this wasn't
pursued during this thesis, is the lack of experience of the footprint based methods in elsa. This
definitely is a possible area of improvement in the projector.

Also note, the current version of the projector only supports X-ray attenuation CT. However, this
projector should be easily adapted to instead of the Radon Transform, yield the derivative of the
Radon Transform as weights. In theory, it should only be necessary to create a the function to
populate the \gls{LUT}, and a very thing wrapper around it to provide the functionality needed for
elsa to use it as a projector.

\chapter{Experiments}\label{chap:experiments}

\section{Reproducibility}\label{sec:experiments_repoduction}

I want this part to be as as reproducible as possible. Therefore, I ran as much as I can with
scripts, which can be found in the GitHub repository for this Thesis. You need to checkout elsa
\todo{add commit hash}, build it including the examples (please see elsa's documentation for that).
Then you'll be able to run all the scripts, with the last argument being the path to the
\textit{example\_argparse} binary, which you just build.

\section{Error measurements}\label{sec:error_measurements}

Error measurements are a delicate topic. They can fake a false sense of security. Metrics might
indicate a improved result, however visually the result might be worse. Therefore, multiple errors
are taken into considerations here.

\begin{definition}[Mean Squared Error]
	One of the most famous error metrics: \textit{Mean Square Error}(MSE). It is defined as the
	squared differences of each pixel value, weighted with the total number of pixels
	\[ MSE = \frac{1}{n} \sum_{i=1}^{n}(x_i - \hat{x}_i)^2\]
	where \(x_i\) is each voxel of the reference image, \(\hat{x}_i\) each voxel of the comparison
	image and \(n\) the total number of voxels in the image.
\end{definition}

Building on top of the MSE, the \textit{Root Mean Square Error}, is the square root of the MSE.
\begin{definition}[Normalized Root Mean Squared Error]
	The \textit{Root Mean Square Error} is defined as
	\[ RMSE = \sqrt{MSE(x, \hat{x}}) \]
	where \(x\) is the reference image and \(\hat{x}\) the comparison image. Further, the
	\textit{Normalized Root Mean Squared Error} is defined as
	\[ NRMSE = \frac{RMSD}{x_{max} - x_{min}} \]
	with \(x_{min}\) and \(x_{max}\) are the minimum and maximum values of the reference image,
	respectively.
\end{definition}
Another frequently used metric is the \textit{Peak Signal to Noise Ration} (PSNR)
\begin{definition}[Peak Signal to Noise Ration]
	The \textit{Peak Signal to Noise Ration} is defined as
	\[ PSNR = 10 \cdot \log_{10}\left( \frac{MAX}{\sqrt{MSE}} \right) \]
	where \(MAX\) is the maximum possible range depending on the data type of the images
\end{definition}
All of the so far given metrics are based on the MSE, i.e.\ they measure based on exact voxel by
voxel values. They measure absolute errors and weight them depending on the exact method. However,
they don't necessarlly have much in common with the visual perception of humans. The
\textit{Structural Similarity Index Measure} (SSIM) is a perception-based approach. The idea for
SSIM is the relation of close pixels to one another and different values important to the human
perception.
\begin{definition}[Structural Similarity Index Measure]
	Given a reference image \(x\) and a comparison image \(\hat{x}\) then the \textit{Structural
		Similarity Index Measure} is given by
	\[ SSIM(x, \hat{x}) = \frac{\left(2 \mu_x \mu_{\hat{x}} + c_1\right) \left( 2
			\sigma_{x, \hat{x}} + c_2 \right)}{\left(\mu_x^2
			+ \mu_{\hat{x}}^2 + c_1 \right) \left( \sigma_x^2 + \sigma_{\hat{x}}^2 + c_2 \right)} \]
	where \(\mu_x\) is the average of \(x\), \(\mu_{\hat{x}}\) is the average of \(\hat{x}\),
	\(\sigma_x^2\) is the variance of \(x\), \(\sigma_{\hat{x}}^2\) is the variance of
	\(\hat{x}\), and \(\sigma_{x, \hat{x}}\) is the covariance of \(x\) and \(\hat{x}\)
	\insertref{DOI:10.1109/TIP.2003.819861 and DOI:10.1007/s10043-009-0119-z}
\end{definition}

\inlinetodo{Add references}

\section{Forward Projection}\label{sec:experiments_forward_projection}

\inlinetodo{Maybe you have time to do implement a analytic sinogram for blob phantoms}

As explained in details in the background part of thesis, the forward projection is in the case of
attenuation X-ray CT, the line integral through the object. It's quality if important for every
reconstruction task.

\inlinetodo{Rework with reformated figures}

\inlinetodo{Describe experiment setup detailed}
In \autoref{fig:sinogram_shepp_logan}, one can see the sinogram of the Shepp-Logan phantom
\insertref{Reference to Shepp-Logan phantom} (see \autoref{fig:shepp_logan_phantom}). If one never
seen a sinogram, each row (in this case, someimtes it is turned 90°) represents the projection of a
certain angle. In this case, the first row is the projection with angle 0° and increments downwards
in equally spaced steps for a total arc of 360°. For this sonogram in total 1024 angles are
computed.

\begin{figure}[H]
	\centering
	% Taken from https://tex.stackexchange.com/a/398309
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[origin=c]{90}{\bfseries Forward projections\strut}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_Blob_windowed.png}}
				\caption{Blob based projector}\label{fig:sinogram_blob}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_BSpline_windowed.png}}
				\caption{B-Spline based projector}\label{fig:sinogram_bspline}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_Siddon_windowed.png}}
				\caption{Siddon's projector}\label{fig:sinogram_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_Joseph_windowed.png}}
				\caption{Joseph's projector}\label{fig:sinogram_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[origin=c]{90}{\bfseries Absolute Normalized Differences\strut}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_difference_Blob_Siddon_windowed.png}}
				\caption{Difference Blob and Siddon}\label{fig:sino_diff_blob_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_difference_Blob_Joseph_windowed.png}}
				\caption{Difference Blob and Joseph}\label{fig:sino_diff_blob_joseph}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_difference_BSpline_Siddon_windowed.png}}
				\caption{Difference B-Spline and Siddon}\label{fig:sino_diff_bspline_siddon}
			\end{subfigure}%
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_difference_BSpline_Joseph_windowed.png}}
				\caption{Difference B-Spline and Joseph}\label{fig:sino_diff_bspline_joseph}
			\end{subfigure}%
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_difference_Blob_BSpline_windowed.png}
				\caption{Difference Blob and B-Spline}\label{fig:sino_diff_blob_bspline}
			\end{subfigure}
			\begin{subfigure}[b]{0.3321\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/plot_sino_differences.png}
				\caption{Cross section of \(180\)° projection}\label{fig:plot_sino_differences}
			\end{subfigure}
			\begin{subfigure}[b]{0.3321\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dphantom_windowed.png}
				\caption{Shepp-Logan phantom}\label{fig:shepp_logan_phantom}
			\end{subfigure}
		}}
	\caption{\subref{fig:sinogram_blob}--\subref{fig:sinogram_joseph} sinogram of \(256 \times
		256\) Shepp-Logan phantom for the Blob based, B-Spline based, Siddon's and Joseph's
		projector (left to right), with \(384\) different poses in a \(360\)° arc around the
		phantom using fan-beam geometry.%
		\subref{fig:sino_diff_blob_siddon}-\subref{fig:sino_diff_bspline_joseph} Absolute
		difference of normalized sinograms between (from left to right), the Blob based to
		Siddon's and Joseph's projector, then the B-Spline based to Siddon's and Joseph's
		projector. \subref{fig:sino_diff_blob_bspline} Absolute difference of normalized
		sinogram between the sinogram for the Blob based and B-Spline based projector.%
		\subref{fig:plot_sino_differences} Plot of cross sections at \(180\)° (i.e.\ the
		center row) of sinograms. The intensity difference of the Blob based projector
		compared to the others is clearly visible. \subref{fig:shepp_logan_phantom} original
		shepp-logan phantom used to create the sinograms}%
	\label{fig:sinogram_shepp_logan}
\end{figure}

However, on this scale fine details will be lost. Therefore, a crop into the center left edge of the
sinogram is given in \autoref{fig:sinogram_shepp_logan_center_crop}. This is the region for the
projection angles around 180° degrees. The Siddon's projector in
\autoref{fig:sinogram_siddon_center_crop} exhibits the strongest artifacts. Similar artifacts are
present in regions around all multiples of 45° degrees (visible in \autoref{fig:sinogram_siddon}, if
zoomed in) Similar artifacts, These are the typical artifacts for ray-driven projectors. The
Joseph's projector in \autoref{fig:sinogram_joseph_center_crop} already reduces these artefacts
successfully.

Both the Blob and B-Spline based projector don't exhibit these kind of artifacts as the Siddon's
projector. However, they also contain less artifacts than the Joseph's one. This is better visible
in the difference images, depicted in \autoref{fig:sino_differences}. Please note that these are
normalized absolute difference, i.e.\ the sinograms are normalized to the interval \(\mathopen[0,
	1\mathclose]\), and then the absolute value of the voxel-by-voxel difference is computed.

The first row of \autoref{fig:sino_differences} show the difference of the sinograms of the Siddon's
and Joseph's projector compared to the Blob based projector. The second row, the difference of
Siddon's and Joseph's to the B-Spline based on. For both projectors, the ring like artifacts from
the Siddon's projector are clearly visible again. However, now one can also see ring-like artifacts
in the difference to the Joseph's projector. They are clearly visible around each multiple of 45°
and 90° degree. Here, it is also clearly visible, that the Joseph's projector has the most artifacts
around the multiples of 45° degrees.

\autoref{fig:sino_diff_blob_bspline} shows the difference between the blob and B-Spline based
projectors. As expected they behave very much identical. The light outlines of the sinogram are
mostly due to the a small difference in brightness in the blob based projector. However, in the 45°
degree cases, they behave differently. \todo{They also different in something around 22.5° degrees,
	find out which exactly}

\begin{figure}[h]
	\centering
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				% \centering
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_croped_Blob.png}
				\caption{Blob based projector}\label{fig:sinogram_blob_center_crop}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				% \centering
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_croped_BSpline.png}
				\caption{B-Spline based projector}\label{fig:sinogram_bspline_center_crop}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				% \centering
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_croped_Siddon.png}
				\caption{Siddon's projector}\label{fig:sinogram_siddon_center_crop}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				% \centering
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_croped_Joseph.png}
				\caption{Joseph's projector}\label{fig:sinogram_joseph_center_crop}
			\end{subfigure}
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				% \centering
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_croped_difference_Blob_Siddon.png}
				\caption{Difference Blob and Siddon}\label{fig:sinogram_difference_blob_siddon_crop}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				% \centering
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_croped_difference_Blob_Joseph.png}
				\caption{Difference Blob and Joseph}\label{fig:sinogram_difference_blob_joseph_crop}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				% \centering
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_croped_difference_BSpline_Siddon.png}
				\caption{Difference B-Spline and Siddon}\label{fig:sinogram_difference_bspline_siddon_crop}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				% \centering
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_croped_difference_BSpline_Joseph.png}
				\caption{Difference B-Spline and Joseph}\label{fig:sinogram_difference_bspline_joseph_crop}
			\end{subfigure}
		}}
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/forward_projection/2dsinogram_Blob_rectangle.png}
				\caption{Sinogram with marked region of crops}\label{fig:sinogram_crop_overview}
			\end{subfigure}
		}}
	\caption{\subref{fig:sinogram_blob_center_crop}--\subref{fig:sinogram_joseph_center_crop}
		crop into the sinogram shown in \autoref{fig:sinogram_shepp_logan}. Showing a part
		of the projections of around \(180\)° to \(225\)°.
		\subref{fig:sinogram_difference_blob_siddon_crop}--\subref{fig:sinogram_difference_bspline_joseph_crop}
		same croped region as the first row, but showing the absolute normalized
		differences. \subref{fig:sinogram_crop_overview} sinogram with rectangle marking the
		croped region imges in
		\subref{fig:sinogram_blob_center_crop}--\subref{fig:sinogram_difference_bspline_joseph_crop}
	}
	\label{fig:sino_differences}
\end{figure}

Overall, one should note that the L2-norms of each sinogram is vastly differently. Especially, the
blob based projector is noticeable brighter. \todo{compute l2 norm and make table out of it, find
	explanation}

\section{Reconstruciton of Synthetic Data}\label{sec:experiments_synthethic_projection}

\inlinetodo{Have a detailed explanation of the setup, including the geometry setup, reconstructio
	solver, parameters choice and such. Have an overview of the phantoms, from very basic
	(rectangular phantom) to complex (`medical' data)}

In this chapter, many different reconstruction tasks are presentend to show different behaviour
under different conditions. All reconstructions are performed using the Fast Iterative
Shrinkage-Thresholding (FISTA) Algorithm \insertref{FISTA ref}. Usually, \(25\) iterations are
performed for the reconstruction unless mentioned otherwise. The regularization parameter is tuned
for each reconstruction to perform best visually. It is given in tables respective tables for the
reconstruction containing the error metrics~\ref{tab:error_metric_shepp_logan}.

\begin{figure}[h]
	\centering
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[origin=c]{90}{\bfseries Reconstruciton\strut}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_blob_croped.png}}
				\caption{Blob based projector}%
				\label{fig:rectangle_recon_artifacts_blob}
			\end{subfigure}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_bspline_croped.png}}
				\caption{B-Spline based projector}%
				\label{fig:rectangle_recon_artifacts_bspline}
			\end{subfigure}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_siddon_croped.png}}
				\caption{Siddon's projector}%
				\label{fig:rectangle_recon_artifacts_siddon}
			\end{subfigure}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dreconstruction_joseph_croped.png}}
				\caption{Joseph's projector}%
				\label{fig:rectangle_recon_artifacts_joseph}
			\end{subfigure}
		}}

	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\rotatebox[origin=c]{90}{\bfseries Difference to phantom\strut}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2ddifference_Blob_croped.png}}
				\caption{Blob based projector}%
				\label{fig:rectangle_recon_difference_blob}
			\end{subfigure}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2ddifference_BSpline_croped.png}}
				\caption{B-Spline based projector}%
				\label{fig:rectangle_recon_difference_bspline}
			\end{subfigure}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2ddifference_Siddon_croped.png}}
				\caption{Siddon's projector}%
				\label{fig:rectangle_recon_difference_siddon}
			\end{subfigure}
			\begin{subfigure}{0.3125\textwidth}
				\stackinset{c}{}{t}{-.2in}{}{%
					\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2ddifference_Joseph_croped.png}}
				\caption{Joseph's projector}%
				\label{fig:rectangle_recon_difference_joseph}
			\end{subfigure}
		}}
	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2ddifference_Blob_BSpline_croped.png}
				\caption{Blob to B-Spline}%
				\label{fig:rectangle_recon_difference_blob_bspline}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_rectangle/2dphantom_rectangle.png}
				\caption{Rectangular phantom}%
				\label{fig:rectangle_recon_phantom}
			\end{subfigure}
		}}
	\caption{\subref{fig:rectangle_recon_artifacts_blob}--\subref{fig:rectangle_recon_artifacts_joseph}
		crop of top left corner of the reconstruction rectangle with different projectors
		\subref{fig:rectangle_recon_difference_blob}--\subref{fig:rectangle_recon_difference_joseph}
		absolute normalized difference of reconstructed image and the phantom in
		\subref{fig:rectangle_recon_phantom}. In order from left to right and top down, the
		differences of the reconstruction using the Blob based, B-Spline, Siddon's and
		Joseph's projector and the original phantom.
		\subref{fig:rectangle_recon_difference_blob_bspline} difference of reconstructions
		using the blob and B-Spline based projector. \subref{fig:rectangle_recon_phantom}
		Rectangular phantom with marked region denoting the croped region of the images in
		\subref{fig:rectangle_recon_artifacts_blob}--\subref{fig:rectangle_recon_difference_blob_bspline}
	}%
	\label{fig:rectangle_recon_artifacts}
\end{figure}

Looking at \autoref{fig:rectangle_recon_artifacts}, the original phantom is depicted at the bottom
(\autoref{fig:rectangle_recon_phantom}). It is a square, centered in the middle of the frame with a
constant value of 1. There, the first row show the blob and B-Spline based projectors, and the
second row the Siddon's and Joseph's projector. Clearly, in both the reconstruction of Siddon's and
Joseph's artifacts can be seen, which are not present in the blob and B-Spline based ones. These are
again due to the nature of the ray-driven approaches and the thin support of the rays.

Looking at the normalized absolute differences, shown in the second row of
\autoref{fig:rectangle_recon_artifacts}, the artifacts already visible in the previous figure are
again clearly visible. Interestingly, both the blob based projector and the B-Spline based on are
cleaner than the other approaches. They do exhibit a touch of glow around the corner, but they are
pretty consistent. Especially, compare to Siddon's method, the glow around the corner is quite
noisy. This is also true for the Siddon's based one, but it's less severe. \todo{Add difference of
	blob to bspline one} No noticeable difference between the blob and B-Spline based projectors can be
notices.

\begin{figure}[h]
	\centering
	\makebox[\textwidth]{ \makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_blob.png}
				\caption{Blob based projector}%
				\label{fig:reconstruction_shepp_logan_blob}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_bspline.png}
				\caption{B-Spline based projector}%
				\label{fig:reconstruction_shepp_logan_bspline}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_siddon.png}
				\caption{Siddon's projector}%
				\label{fig:reconstruction_shepp_logan_siddon}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2dreconstruction_joseph.png}
				\caption{Joseph's projector}%
				\label{fig:reconstruction_shepp_logan_joseph}
			\end{subfigure}
		}} \\
	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2ddifference_blob.png}
				\caption{blob based projector}%
				\label{fig:reconstruction_shepp_logan_diff_blob}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2ddifference_bspline.png}
				\caption{b-spline based projector}%
				\label{fig:reconstruction_shepp_logan_diff_bspline}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2ddifference_siddon.png}
				\caption{siddon's projector}%
				\label{fig:reconstruction_shepp_logan_diff_siddon}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_shepp_logan/2ddifference_joseph.png}
				\caption{joseph's projector}%
				\label{fig:reconstruction_shepp_logan_diff_joseph}
			\end{subfigure}
		}}
	\caption{Top row: Reconstruction of Shepp-Logan phantom using FISTA, Bottom row: differences
		to ground truth}%
	\label{fig:reconstruction_shepp_logan}
\end{figure}

Without trying to repeat the results to often, as a last synthetic data set, the reconstruction of
the Sheep-Logan phantom is shown the top row of \autoref{fig:reconstruction_shepp_logan}. Similarly,
to before both, the blob and B-Spline based projector exhibit no ring like artifacts and look quite
clean compared to both the Siddon and Joseph projectors. And again no noticeable difference, can be
seen between the blob and B-Spline projectors. \todo{also add difference between blob and B-Spline
	based one}. This is again noticeable in the differences given in the bottom row of
\autoref{fig:reconstruction_shepp_logan}

\autoref{tab:error_metric_shepp_logan} shows the different error metrics for the reconstruction of
the Shepp-Logan phantom. They are all quite similar and all in the neighbourhood of \(0.00002\)
(MSR), \(0.001\) (RMSR), \(0.5\) (PSNR) or \(0.01\) (SSIM). \todo{validate via python/matlab
	scripts}

\begin{table}%
	\centering
	\csvreader[
		head to column names,
		separator=semicolon,
		tabular = cccccc,
		table head = \toprule \textbf{Projector} & \textbf{MSE} \downarrow & \textbf{NRMSE} \downarrow & \textbf{PSNR} \uparrow & \textbf{SSIM} \uparrow \\\midrule,
		table foot = \bottomrule
	]{figures/experiments/reconstruction_shepp_logan/metrics.csv}{}{%
		\csvlinetotablerow%
	}
	\caption{Error metrics for the reconstruction of the Shepp-Logan phantom using FISTA}%
	\label{tab:error_metric_shepp_logan}
\end{table}

\subsection{Few Angle Reconstruction}\label{sec:experiments_few_angle}

\begin{table}%
	\centering
	\csvreader[
		head to column names,
		separator=semicolon,
		tabular = cccccc,
		table head = \toprule \textbf{Projector} & \textbf{MSE} \downarrow & \textbf{NRMSE} \downarrow & \textbf{PSNR} \uparrow & \textbf{SSIM} \uparrow \\\midrule,
		table foot = \bottomrule
	]{figures/experiments/reconstruction_fewangles/metrics.csv}{}{%
		\csvlinetotablerow%
	}
	\caption{error metric for reconstruction of shepp-logan phantom using fista with few angles}%
	\label{tab:error_metric_shepp_logan_few_angles}
\end{table}

\begin{figure}[h]
	\centering
	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2dreconstruction_blob.png}
				% \caption{blob based projector}%
				% \label{fig:reconstruction_fewangles_blob}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2dreconstruction_bspline.png}
				% \caption{b-spline based projector}%
				% \label{fig:reconstruction_fewangles_bspline}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2dreconstruction_siddon.png}
				% \caption{siddon's projector}%
				% \label{fig:reconstruction_fewangles_siddon}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2dreconstruction_joseph.png}
				% \caption{joseph's projector}%
				% \label{fig:reconstruction_fewangles_joseph}
			\end{subfigure}
		}}
	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2ddifference_blob.png}
				% \caption{blob based projector}%
				% \label{fig:reconstruction_diff_fewangles_blob}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2ddifference_bspline.png}
				% \caption{b-spline based projector}%
				% \label{fig:reconstruction_diff_fewangles_bspline}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2ddifference_siddon.png}
				% \caption{siddon's projector}%
				% \label{fig:reconstruction_diff_fewangles_siddon}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2ddifference_joseph.png}
				% \caption{joseph's projector}%
				% \label{fig:reconstruction_diff_fewangles_joseph}
			\end{subfigure}
		}}
	\makebox[\textwidth]{
		\makebox[1.3\textwidth]{%
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2dreconstruction_blob_croped.png}
				% \caption{blob based projector}%
				% \label{fig:reconstruction_crop_fewangles_blob}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2dreconstruction_bspline_croped.png}
				% \caption{b-spline based projector}%
				% \label{fig:reconstruction_crop_fewangles_bspline}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2dreconstruction_siddon_croped.png}
				% \caption{siddon's projector}%
				% \label{fig:reconstruction_crop_fewangles_siddon}
			\end{subfigure}
			\begin{subfigure}[b]{0.3125\textwidth}
				\includegraphics[width=\textwidth]{./figures/experiments/reconstruction_fewangles/2dreconstruction_joseph_croped.png}
				% \caption{joseph's projector}%
				% \label{fig:reconstruction_crop_fewangles_joseph}
			\end{subfigure}
		}}
	\caption{top row: Reconstruction of Shepp-Logan phantom with few angles, middle row:
		differences to ground truth, bottom row: crop into portion of the reconstruction,from left
		to right: the blob based projector, the B-Spline based projector, Siddon's projector,
		Joseph's projector}%
	\label{fig:reconstruction_fewangles}
\end{figure}

\subsection{Behaviour in the Presence of Noise}

\inlinetodo{extent elsa example to be able to add noise}

\section{Quality Summary}\label{sec:experiments_quality_projection}

\subsection{Reduced artifacts in Forward Projection}\label{sec:experiments_artifacts_forward}

\subsection{Reduced artifacts in Reconstruction}\label{sec:experiments_artifacts_reconstruction}

\section{Performance Overview}\label{sec:experiments_performance_projection}
